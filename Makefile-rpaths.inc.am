## -*- mode: makefile -*-

##
## This file is part of the Score-P software ecosystem (http://www.score-p.org)
##
## Copyright (c) 2023-2024,
## Forschungszentrum Juelich GmbH, Germany
##
## This software may be modified and distributed under the terms of
## a BSD-style license.  See the COPYING file in the package base
## directory for details.
##

# Generate the Makefile snippet $(RPATHS_MAKEFILE), containing
# information for portably rpathing libtool-programs that link
# to libtool-libraries that require external libraries.
# Unfortunately, libtool does not provide this information, although
# available, in a portable and robust manner for shared objects,
# which manifest in failure at load-time.
# $(RPATHS_MAKEFILE) contains a key-value pair per installed
# libtool library of the form:
#
#   <lib>_la_needs_RPATHS = -R<dir>[ -R<dir>]
#
# where the external library can be found in <dir>.
# $(RPATHS_MAKEFILE) gets included, thus the new variables are
# easily accessible. The new variables are generated from -R
# entries in <lib>_LDFLAGS and the global LDFLAGS.
# Use the new variables like this for (bin|check|...)_PROGRAMS:
# If <program>_LDADD contains <lib>.la, amend <program>_LDFLAGS:
#
#   <program>_LDFLAGS += $(<lib>_la_needs_RPATHS)
#
# Note that installed shared libtool libs are supposed to be self-
# contained, i.e., they have all required NEEDED and RPATH/RUNPATH
# entries for the loader to properly start a non-libtool program
# that links to a libtool library.
#
# Note that $(RPATHS_MAKEFILE) is included into this Makefile only in
# --enable-shared case. In static-only case, $(RPATHS_MAKEFILE) still
# gets generated in order to generate $(CONFIG_EXTERNAL_LIBS_HPP), see
# below.
#
#
# $(RPATHS_MAKEFILE) is generated by config.status and whenever Makefile
# changes. We create an empty $(RPATHS_MAKEFILE) before recursively
# calling $(MAKE) to prevent an infinite loop.

# ---
# Ensure that <name> in all lib<name>.la is an automake canonicalized
# name as <name> is used to create variables. See e.g., the rule
# `$(CONFIG_EXTERNAL_LIBS_HPP)`. Canonicalized
# names contain just letters, numbers, the strudel (@), and the
# underscore.

CLEANFILES += ensure_ltlibraries_canonicalized

ensure_ltlibraries_canonicalized: Makefile
	@for i in $(lib_LTLIBRARIES:.la=); do \
	    canononical_name=$$(echo "$$i" | tr -c 'A-Za-z0-9_@\n' '_' ); \
	    if test "$$canononical_name" != "$$i"; then \
	        echo "ERROR: $$i.la is not a canonical name. Please change to e.g., $$canononical_name.la." >&2; \
	        exit 1; \
	    fi; \
	done; \
	touch $@

DISTCLEANFILES += $(RPATHS_MAKEFILE)

$(RPATHS_MAKEFILE): Makefile
	$(AM_V_GEN): > $(RPATHS_MAKEFILE); \
	$(MAKE) $(lib_lt_ldflags)

lib_lt_ldflags = $(lib_LTLIBRARIES:.la=_la_LDFLAGS)
$(lib_lt_ldflags): ensure_ltlibraries_canonicalized
	@needs_rpaths_var=$$(echo "$@" | $(SED) "s|_LDFLAGS|_needs_RPATHS|"); \
	needs_rpaths_value=$$(echo "$($@) $(LDFLAGS)" | $(AWK) ' \
	    { \
	        gsub(/-R +/, "-R"); \
	        for ( i=1; i<=NF; i++ ) { \
	            if ( match( $$i, /^-R/ ) ) { \
	                count[$$i]++; \
	                if ( count[$$i] == 1 ) { \
	                    paths[idx++]=$$i \
	                } \
	            } \
	        } \
	    } \
	    END { \
	        for ( i=0; i<idx; i++ ) { \
	            if ( length( result ) == 0 ) { \
	                result=paths[i] \
	            } else { \
	                result=result " " paths[i] \
	            } \
	        } \
	        print result \
	    } \
	'); \
	echo "$$needs_rpaths_var = $$needs_rpaths_value" >> $(RPATHS_MAKEFILE)


if HAVE_BUILD_SHARED_LT_LIBRARIES
# Include generated $(RPATHS_MAKEFILE). Prevent automake-time inclusion
# by expanding at configure time rather than automake time.
@INLCUDE_RPATHS_MAKEFILE@
endif HAVE_BUILD_SHARED_LT_LIBRARIES


# Generate the C++-header file $(CONFIG_EXTERNAL_LIBS_HPP) containing
# information for linking and rpathing. The information is fed into a
# std::map<std::string, la_object> via the rule lib_lt_libraries (see
# below and generate-library-dependencies-la-object.hpp) which is used
# by the <pkg>-config tools.
#
# We feed the information into the map by generating two preprocessor
# defines per installed libtool library, providing information about
# all external libraries <ext-lib> residing in <dir>, that are
# required to link a static <lib>.a into a non-libtool program:
#
#   #define $(AFS_PACKAGE_BUILD_NAME)_<lib>_NEEDS_LIBDIRS <dir>[:<dir>]
#   #define $(AFS_PACKAGE_BUILD_NAME)_<lib>_NEEDS_LIBS -l<ext-lib>[ -l<ext-lib>]
#
# For shared <LIB>.so, these preprocessor defines are generated empty,
# as the installed shared libs are supposed to be self-contained.
#
# Here, <dir> is supposed to be used as '-L<dir> -Wl,-rpath -Wl,<dir>' (by
# the <pkg>-config tool).
#
# In the static case, we rely on $(RPATHS_MAKEFILE) for the
# _NEEDS_LIBDIRS generation, and on *_la_LIBADD and the global LIBS
# variables for the _NEEDS_LIBS generation. See lib_lt_needs_libdirs
# and lib_lt_needs_libs rules.
# We ignore .la files in *_la_LIBADD variables. They originate from
# noinst libraries.

BUILT_SOURCES += $(CONFIG_EXTERNAL_LIBS_HPP)
CLEANFILES += $(CONFIG_EXTERNAL_LIBS_HPP)

$(CONFIG_EXTERNAL_LIBS_HPP): Makefile $(RPATHS_MAKEFILE)
	$(AM_V_GEN): > $@; \
	echo "#ifndef $(CONFIG_EXTERNAL_LIBS_HPP_INCLUDE_GUARD)" >> $@; \
	echo "#define $(CONFIG_EXTERNAL_LIBS_HPP_INCLUDE_GUARD)" >> $@; \
	echo "#include <generate-library-dependencies-la-object.hpp>" >> $@; \
	echo "#include <map>" >> $@; \
	echo "#define $(AFS_PACKAGE_BUILD_NAME)_BUILDDIR \"$(abs_builddir)\"" >> $@; \
	echo "#define $(AFS_PACKAGE_BUILD_NAME)_LIBDIR \"$(libdir)\"" >> $@; \
	$(MAKE) $(lib_lt_needs_libdirs); \
	$(MAKE) $(lib_lt_needs_libs); \
	echo "static void" >> $@; \
	echo "add_library_dependencies_$(AFS_PACKAGE_BUILD_name)( std::map<std::string, la_object>* la_objects )" >> $@; \
	echo "{" >> $@; \
	$(MAKE) $(lib_lt_libraries); \
	echo "}" >> $@; \
	echo "#endif // $(CONFIG_EXTERNAL_LIBS_HPP_INCLUDE_GUARD)" >> $@;

lib_lt_libraries = $(lib_LTLIBRARIES:.la=)
$(lib_lt_libraries):
	@for i in $(lib_lt_libraries); do \
	    echo "    (*la_objects)[ \"$$i\" ] = la_object( \"$$i\"," \
	         "$(AFS_PACKAGE_BUILD_NAME)_BUILDDIR," \
	         "$(AFS_PACKAGE_BUILD_NAME)_LIBDIR," \
	         "$(AFS_PACKAGE_BUILD_NAME)_$${i}_NEEDS_LIBS," \
	         "$(AFS_PACKAGE_BUILD_NAME)_$${i}_NEEDS_LIBDIRS );"; \
	done >> $(CONFIG_EXTERNAL_LIBS_HPP)


if HAVE_BUILD_STATIC_LT_LIBRARIES

lib_lt_needs_libdirs = lib_lt_needs_libdirs
lib_lt_needs_libdirs:
	@cat $(RPATHS_MAKEFILE) | $(AWK) ' \
	    { \
	        gsub( /_la_needs_RPATHS/, "_NEEDS_LIBDIRS" ); \
	        define="#define $(AFS_PACKAGE_BUILD_NAME)_" $$1 " "; \
	        gsub( /^lib[a-zA-Z0-9_]+LIBDIRS =/, "" ); \
	        gsub( /^ -R/,"" ); \
	        gsub( / -R/, ":" ); \
	        gsub( / /, "" ); \
	        print define "\"" $$0 "\"" \
	    }' >> $(CONFIG_EXTERNAL_LIBS_HPP)

lib_lt_needs_libs = $(lib_LTLIBRARIES:.la=_la_LIBADD)
$(lib_lt_needs_libs):
	@needs_libs_var=$$(echo "$@" | $(AWK) ' \
	    { \
	        gsub( /_la_LIBADD/, "_NEEDS_LIBS" ); \
	        print $$0; \
	    } \
	'); \
	needs_libs_value=$$(echo "$($@)" | $(AWK) ' \
	    { \
	        gsub( /lib[a-zA-Z0-9_.-]+\.la/, "" ); \
	        gsub( /^ +/, "" ); \
	        print $$0; \
	    } \
	'); \
	echo "#define $(AFS_PACKAGE_BUILD_NAME)_$$needs_libs_var \"$$needs_libs_value $(LIBS)\"" | \
	    tr -s ' ' | $(SED) 's/ *"$$/"/g' >> $(CONFIG_EXTERNAL_LIBS_HPP)

# Nothing to in the pure-static case.
shared-objects-self-contained:

else !HAVE_BUILD_STATIC_LT_LIBRARIES

lib_lt_needs_libdirs = $(lib_LTLIBRARIES:.la=_NEEDS_LIBDIRS)
$(lib_lt_needs_libdirs):
	@echo "#define $(AFS_PACKAGE_BUILD_NAME)_$@ \"\"" >> $(CONFIG_EXTERNAL_LIBS_HPP)

lib_lt_needs_libs = $(lib_LTLIBRARIES:.la=_NEEDS_LIBS)
$(lib_lt_needs_libs):
	@echo "#define $(AFS_PACKAGE_BUILD_NAME)_$@ \"\"" >> $(CONFIG_EXTERNAL_LIBS_HPP)

if AFS_BUILD_EQUALS_HOST

# To abort installcheck if not all shared lib_LTLIBRARIES are self-contained,
# add shared-objects-self-contained to INSTALLCHECK_LOCAL.
lib_lt_so = $(lib_LTLIBRARIES:.la=.so)
shared-objects-self-contained:
	selfcontained=yes; \
	for so in $(lib_lt_so); do \
	    if ldd "$(libdir)/$$so" | $(GREP) 'not found' >/dev/null; then \
	        selfcontained=no; \
	        echo "not selfcontained: ldd $(libdir)/$$so"; \
	        ldd "$(libdir)/$$so"; \
	    fi; \
	done; \
	if test "x$$selfcontained" = xno; then \
	    echo "shared objects not self-contained"; \
	    exit 1; \
	fi

else !AFS_BUILD_EQUALS_HOST

# Cannot use ldd if build and host differ.
shared-objects-self-contained:

endif !AFS_BUILD_EQUALS_HOST

endif !HAVE_BUILD_STATIC_LT_LIBRARIES
