## -*- mode: makefile -*-

##
## This file is part of the Score-P software ecosystem (http://www.score-p.org)
##
## Copyright (c) 2023-2024,
## Forschungszentrum Juelich GmbH, Germany
##
## This software may be modified and distributed under the terms of
## a BSD-style license.  See the COPYING file in the package base
## directory for details.
##

# Generate the Makefile snippet $(RPATHS_MAKEFILE), containing
# information for portably rpathing libtool-programs that link
# to libtool-libraries that require external libraries.
# Unfortunately, libtool does not provide this information, although
# available, in a portable and robust manner for shared objects,
# which manifest in failure at load-time.
# $(RPATHS_MAKEFILE) contains a key-value pair per installed
# libtool library of the form:
#
#   <lib>_la_needs_RPATHS = -R<dir>[ -R<dir>]
#
# where the external library can be found in <dir>.
# $(RPATHS_MAKEFILE) gets included, thus the new variables are
# easily accessible. The new variables are generated from -R
# entries in <lib>_LDFLAGS and the global LDFLAGS.
# Use the new variables like this for (bin|check|...)_PROGRAMS:
# If <program>_LDADD contains <lib>.la, amend <program>_LDFLAGS:
#
#   <program>_LDFLAGS += $(<lib>_la_needs_RPATHS)
#
# Note that installed shared libtool libs are supposed to be self-
# contained, i.e., they have all required NEEDED and RPATH/RUNPATH
# entries for the loader to properly start a non-libtool program
# that links to a libtool library.
#
# Note that $(RPATHS_MAKEFILE) is included into this Makefile only in
# --enable-shared case. In static-only case, $(RPATHS_MAKEFILE) still
# gets generated in order to generate $(CONFIG_EXTERNAL_LIBS_HPP), see
# below.
#
#
# $(RPATHS_MAKEFILE) is generated by config.status and whenever Makefile
# changes. We create an empty $(RPATHS_MAKEFILE) before recursively
# calling $(MAKE) to prevent an infinite loop. The same applies to
# Makefile.export. Makefile.export is supposed to be included via
# '-include ../build-foo/Makefile.export' into a build-bar's Makefile.
# Here, the leading hyphen guarantees progress even if the file doesn't
# exist.

# ---
# Ensure that <name> in all lib<name>.la is an automake canonicalized
# name as <name> is used to create variables. See e.g., the rules
# `Makefile.export` and `$(CONFIG_EXTERNAL_LIBS_HPP)`. Canonicalized
# names contain just letters, numbers, the strudel (@), and the
# underscore.

CLEANFILES += ensure_ltlibraries_canonicalized

ensure_ltlibraries_canonicalized: Makefile
	@for i in $(lib_LTLIBRARIES:.la=) $(noinst_LTLIBRARIES:.la=); do \
	    canononical_name=$$(echo "$$i" | tr -c 'A-Za-z0-9_@\n' '_' ); \
	    if test "$$canononical_name" != "$$i"; then \
	        echo "ERROR: $$i.la is not a canonical name. Please change to e.g., $$canononical_name.la." >&2; \
	        exit 1; \
	    fi; \
	done; \
	touch $@

DISTCLEANFILES += $(RPATHS_MAKEFILE)


# ---
# Dump noinst_LTLIBRARIES's `lib<name>_la_needs_LDFLAGS` and
# `lib<name>_la_needs_LIBS` as
#
#   lib<name>_la_needs_LDFLAGS = $(lib<name>_la_needs_LDFLAGS)
#   lib<name>_la_needs_LIBS = # $(lib<name>_la_needs_LIBS)
#
# into `build-<foo>/Makefile.export` to let `build-<bar>/Makefile`
# consume these variables in case they use non-local noinst
# LTLIBRARIES (e.g., libutils.la).

DISTCLEANFILES += Makefile.export

Makefile.export: Makefile ensure_ltlibraries_canonicalized
	$(AM_V_GEN): > Makefile.export; \
	$(MAKE) gen_export

gen_export: $(noinst_lt_needs_ldflags) $(noinst_lt_needs_libs)

noinst_lt_needs_ldflags = $(noinst_LTLIBRARIES:.la=_la_needs_LDFLAGS)
$(noinst_lt_needs_ldflags):
	@var=$$(echo "$@"); \
	value=$$(echo "$($@)"); \
	if test -n "$${value// }"; then \
	    echo "$$var = $$value" >> Makefile.export; \
	fi

noinst_lt_needs_libs = $(noinst_LTLIBRARIES:.la=_la_needs_LIBS)
$(noinst_lt_needs_libs):
	@var=$$(echo "$@"); \
	value=$$(echo "$($@)"); \
	if test -n "$${value// }"; then \
	    echo "$$var = $$value" >> Makefile.export; \
	fi

$(RPATHS_MAKEFILE): Makefile
	$(AM_V_GEN): > $(RPATHS_MAKEFILE); \
	test -z "$(lib_lt_ldflags)" || $(MAKE) $(lib_lt_ldflags)

lib_lt_ldflags = $(lib_LTLIBRARIES:.la=_la_LDFLAGS)
$(lib_lt_ldflags): ensure_ltlibraries_canonicalized
	@needs_rpaths_var=$$(echo "$@" | $(SED) "s|_LDFLAGS|_needs_RPATHS|"); \
	needs_rpaths_value=$$(echo "$($@) $(LDFLAGS)" | $(AWK) ' \
	    { \
	        gsub(/-R +/, "-R"); \
	        for ( i=1; i<=NF; i++ ) { \
	            if ( match( $$i, /^-R/ ) ) { \
	                count[$$i]++; \
	                if ( count[$$i] == 1 ) { \
	                    paths[idx++]=$$i \
	                } \
	            } \
	        } \
	    } \
	    END { \
	        for ( i=0; i<idx; i++ ) { \
	            if ( length( result ) == 0 ) { \
	                result=paths[i] \
	            } else { \
	                result=result " " paths[i] \
	            } \
	        } \
	        print result \
	    } \
	'); \
	echo "$$needs_rpaths_var = $$needs_rpaths_value" >> $(RPATHS_MAKEFILE)


if HAVE_BUILD_SHARED_LT_LIBRARIES
# Include generated $(RPATHS_MAKEFILE). Prevent automake-time inclusion
# by expanding at configure time rather than automake time.
@INLCUDE_RPATHS_MAKEFILE@
endif HAVE_BUILD_SHARED_LT_LIBRARIES


# ---
# Generate the C++-header file $(CONFIG_EXTERNAL_LIBS_HPP), i.e.,
# `../src/config-external-libs-<AFS_PACKAGE_BUILD_name>.hpp`,
# containing information for linking and rpathing of installed
# libraries, intended to be used by the <pkg>-config tools. The
# information is provided via the rules $(lib_lt_needs_libdirs)`,
# `$(lib_lt_needs_libs)` and inserted into a std::map<std::string,
# la_object> via the rule `$(gen_config_external_libs_body)`, see
# below and the file generate-library-dependencies-la-object.hpp.
#
# For each installed static libtool library <lib>.a, we provide two
# preprocessor defines, containing information about all external
# libraries <ext-lib> residing in <dir>, that are required to link
# this static <lib>.a into a non-libtool program:
#
#   #define $(AFS_PACKAGE_BUILD_NAME)_<lib>_NEEDS_LIBDIRS "<dir>[:<dir>]"
#   #define $(AFS_PACKAGE_BUILD_NAME)_<lib>_NEEDS_LIBS "-l<ext-lib>[ -l<ext-lib>]"
#
# <dir> is supposed to be used as '-L<dir> -Wl,-rpath -Wl,<dir>' (by
# the <pkg>-config tool).
#
# For installed shared libtool libraries <lib>.so, these preprocessor
# defines are generated empty, as the installed shared libs are
# supposed to be self-contained, see rule
# `shared-objects-self-contained`.

CLEANFILES += $(CONFIG_EXTERNAL_LIBS_HPP)

$(CONFIG_EXTERNAL_LIBS_HPP): Makefile ensure_ltlibraries_canonicalized
	$(AM_V_GEN): > $@; \
	printf '%s\n%s\n%s\n%s\n%s\n%s\n' \
	       "#ifndef $(CONFIG_EXTERNAL_LIBS_HPP_INCLUDE_GUARD)" \
	       "#define $(CONFIG_EXTERNAL_LIBS_HPP_INCLUDE_GUARD)" \
	       "#include <generate-library-dependencies-la-object.hpp>" \
	       "#include <map>" \
	       "#define $(AFS_PACKAGE_BUILD_NAME)_BUILDDIR \"$(abs_builddir)\"" \
	       "#define $(AFS_PACKAGE_BUILD_NAME)_LIBDIR \"$(libdir)\"" >> $@; \
	$(MAKE) gen_config_external_libs_defines; \
	printf '%s\n%s\n%s\n' \
	       "static void" \
	       "add_library_dependencies_$(AFS_PACKAGE_BUILD_name)( std::map<std::string, la_object>* la_objects )" \
	       "{" >> $@; \
	test -z "$(gen_config_external_libs_body)" || $(MAKE) $(gen_config_external_libs_body); \
	printf '%s\n%s\n' \
	       "}" \
	       "#endif // $(CONFIG_EXTERNAL_LIBS_HPP_INCLUDE_GUARD)" >> $@;

gen_config_external_libs_defines: $(lib_lt_needs_libdirs) $(lib_lt_needs_libs)

gen_config_external_libs_body = $(lib_LTLIBRARIES:.la=)
$(gen_config_external_libs_body):
	@echo "    (*la_objects)[ \"$@\" ] = la_object( \"$@\"," \
	      "$(AFS_PACKAGE_BUILD_NAME)_BUILDDIR," \
	      "$(AFS_PACKAGE_BUILD_NAME)_LIBDIR," \
	      "$(AFS_PACKAGE_BUILD_NAME)_$@_NEEDS_LIBS," \
	      "$(AFS_PACKAGE_BUILD_NAME)_$@_NEEDS_LIBDIRS );" \
	      >> $(CONFIG_EXTERNAL_LIBS_HPP)


if HAVE_BUILD_STATIC_LT_LIBRARIES

lib_lt_needs_libdirs = $(lib_LTLIBRARIES:.la=_la_LDFLAGS)
$(lib_lt_needs_libdirs):
	@needs_rpaths_var=$$(echo "$@" | $(SED) "s|_la_LDFLAGS|_NEEDS_LIBDIRS|"); \
	needs_rpaths_value=$$(echo "$($@) $(LDFLAGS)" | $(AWK) ' \
	    { \
	        gsub(/-R +/, "-R"); \
	        for ( i=1; i<=NF; i++ ) { \
	            if ( match( $$i, /^-R/ ) ) { \
	                count[$$i]++; \
	                if ( count[$$i] == 1 ) { \
	                    gsub("-R", "", $$i); \
	                    paths[idx++]=$$i \
	                } \
	            } \
	        } \
	    } \
	    END { \
	        for ( i=0; i<idx; i++ ) { \
	            if ( length( result ) == 0 ) { \
	                result=paths[i] \
	            } else { \
	                result=result ":" paths[i] \
	            } \
	        } \
	        print result \
	    } \
	'); \
	echo "#define $(AFS_PACKAGE_BUILD_NAME)_$$needs_rpaths_var \"$$needs_rpaths_value\"" >> $(CONFIG_EXTERNAL_LIBS_HPP)

# Below, we ignore .la files in *_la_LIBADD variables as they originate from
# noinst libraries that will be squashed into the installed libraries.
lib_lt_needs_libs = $(lib_LTLIBRARIES:.la=_la_LIBADD)
$(lib_lt_needs_libs):
	@needs_libs_var=$$(echo "$@" | $(AWK) ' \
	    { \
	        gsub( /_la_LIBADD/, "_NEEDS_LIBS" ); \
	        print $$0; \
	    } \
	'); \
	needs_libs_value=$$(echo "$($@)" | $(AWK) ' \
	    { \
	        gsub( /(\.\.\/build-[a-z]+\/)?lib[a-zA-Z0-9_.-]+\.la/, "" ); \
	        gsub( /^ +/, "" ); \
	        print $$0; \
	    } \
	'); \
	echo "#define $(AFS_PACKAGE_BUILD_NAME)_$$needs_libs_var \"$$needs_libs_value $(LIBS)\"" | \
	    tr -s ' ' | $(SED) 's/ *"$$/"/g' >> $(CONFIG_EXTERNAL_LIBS_HPP)

else !HAVE_BUILD_STATIC_LT_LIBRARIES

lib_lt_needs_libdirs = $(lib_LTLIBRARIES:.la=_NEEDS_LIBDIRS)
$(lib_lt_needs_libdirs):
	@echo "#define $(AFS_PACKAGE_BUILD_NAME)_$@ \"\"" >> $(CONFIG_EXTERNAL_LIBS_HPP)

lib_lt_needs_libs = $(lib_LTLIBRARIES:.la=_NEEDS_LIBS)
$(lib_lt_needs_libs):
	@echo "#define $(AFS_PACKAGE_BUILD_NAME)_$@ \"\"" >> $(CONFIG_EXTERNAL_LIBS_HPP)

endif !HAVE_BUILD_STATIC_LT_LIBRARIES


# ---
# Try to check with `ldd` if installed shared libraries are
# self-contained, i.e., all NEEDED entries can be resolved at
# load-time, either via the current environment or the RUNPATH or
# RPATH entries in the shared object.
#
# To abort `make installcheck` if not all shared lib_LTLIBRARIES are
# self-contained, add `shared-objects-self-contained` as prerequisite
# to `installcheck-local`.

if HAVE_BUILD_STATIC_LT_LIBRARIES

# Nothing to do in the pure-static case.
shared-objects-self-contained:

else !HAVE_BUILD_STATIC_LT_LIBRARIES

if AFS_BUILD_EQUALS_HOST

lib_lt_so = $(lib_LTLIBRARIES:.la=.so)
shared-objects-self-contained:
	@selfcontained=yes; \
	list='$(lib_lt_so)'; test -n "$(libdir)" || list=; \
	for so in $$list; do \
	    if LC_ALL=C ldd "$(libdir)/$$so" 2>/dev/null | ${GREP} 'not found' >/dev/null; then \
	        selfcontained=no; \
	        echo "not selfcontained: ldd $(libdir)/$$so"; \
	        ldd "$(libdir)/$$so"; \
	    fi; \
	done; \
	if test "x$$selfcontained" = xno; then \
	    echo "shared objects not self-contained"; \
	    exit 1; \
	fi

else !AFS_BUILD_EQUALS_HOST

# Cannot use ldd if build and host differ.
shared-objects-self-contained:

endif !AFS_BUILD_EQUALS_HOST

endif !HAVE_BUILD_STATIC_LT_LIBRARIES
