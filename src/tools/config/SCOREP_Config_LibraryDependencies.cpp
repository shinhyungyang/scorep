/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2013,
 * RWTH Aachen University, Germany
 *
 * Copyright (c) 2009-2013,
 * Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *
 * Copyright (c) 2009-2013, 2016-2017, 2024,
 * Technische Universitaet Dresden, Germany
 *
 * Copyright (c) 2009-2013,
 * University of Oregon, Eugene, USA
 *
 * Copyright (c) 2009-2013, 2017, 2024,
 * Forschungszentrum Juelich GmbH, Germany
 *
 * Copyright (c) 2009-2014,
 * German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *
 * Copyright (c) 2009-2013,
 * Technische Universitaet Muenchen, Germany
 *
 * This software may be modified and distributed under the terms of
 * a BSD-style license.  See the COPYING file in the package base
 * directory for details.
 */

/**
 * @file
 *
 * Implements the representation and analysis of library dependencies
 */

#include <config.h>

#include <iostream>
#include <stdlib.h>
#include <cstring>

#include "SCOREP_Config_LibraryDependencies.hpp"

#include <scorep_tools_utils.hpp>
#include <scorep_config_tool_backend.h>

using namespace std;

/* config-external-libs-<AFS_BUILD_name>.hpp are generated by
 * build-config/common/Makefile-rpaths.inc.am, see the
 * $(CONFIG_EXTERNAL_LIBS_HPP) target.
 */

#include <config-external-libs-backend.hpp>
#if HAVE( MPI_SUPPORT )
#include <config-external-libs-mpi_backend.hpp>
#endif /* MPI_SUPPORT */
#if HAVE( SHMEM_SUPPORT )
#include <config-external-libs-shmem_backend.hpp>
#endif /* SHMEM_SUPPORT */
#include <config-external-libs-score.hpp>

/* **************************************************************************************
                                                  class SCOREP_Config_LibraryDependencies
****************************************************************************************/

SCOREP_Config_LibraryDependencies::SCOREP_Config_LibraryDependencies( void )
{
    add_library_dependencies_backend( &m_library_objects );
    #if HAVE( MPI_SUPPORT )
    add_library_dependencies_mpi_backend( &m_library_objects );
    #endif /* MPI_SUPPORT */
    #if HAVE( SHMEM_SUPPORT )
    add_library_dependencies_shmem_backend( &m_library_objects );
    #endif /* SHMEM_SUPPORT */
    add_library_dependencies_score( &m_library_objects );
}

void
SCOREP_Config_LibraryDependencies::insert( const string& libName,
                                           const string& libInstallDir )
{
    deque<string> install_dir = { libInstallDir };
    install_dir = RemoveSystemPath( install_dir );
    m_library_objects.insert(
        std::make_pair( libName,
                        LibraryData( libName,
                                     "",    // buildDir of no use for libwrapped lib
                                     install_dir.empty() ? "" : install_dir.front(),
                                     "", "" // libwrapped libs are supposed to be self-contained
                                     ) ) );
}

deque<string>
SCOREP_Config_LibraryDependencies::getLibraries( const deque<string>& inputLibs,
                                                 bool                 honorLibs,
                                                 bool                 honorDeps )
{
    /* Traversing backwards will add the -l flags from the scorep_* lib last.
       this makes the system more robust against broken dependencies in installed
       .la files of other libraries, in particular libbfd.
       During configure we tested whether linking works and this is more reliable
       than installed .la files. */
    deque<string>                   deps = get_dependencies( inputLibs, true, honorDeps );
    deque<string>                   libs;
    deque<string>::reverse_iterator i;
    for ( i = deps.rbegin(); i != deps.rend(); i++ )
    {
        const LibraryData& obj = m_library_objects[ *i ];
        libs.push_front( "-l" + obj.m_lib_name.substr( 3 ) );
        if ( honorDeps )
        {
            libs.insert( libs.end(),
                         obj.m_needs_libs.begin(),
                         obj.m_needs_libs.end() );
        }
    }

    libs = remove_double_entries_keep_last( libs );

    if ( !honorLibs )
    {
        libs.erase( libs.begin(), libs.begin() + inputLibs.size() );
    }

    return libs;
}

string
SCOREP_Config_LibraryDependencies::getLDFlags( const deque<string>& libs,
                                               bool                 install )
{
    deque<string>           deps = get_dependencies( libs );
    deque<string>           libdirs;
    deque<string>::iterator i;
    for ( i = deps.begin(); i != deps.end(); i++ )
    {
        const LibraryData& obj = m_library_objects[ *i ];
        if ( !install )
        {
            libdirs.push_back( obj.m_build_dir + "/.libs" );
        }
        libdirs.push_back( obj.m_install_dir );
        libdirs.insert( libdirs.end(),
                        obj.m_needs_libdirs.begin(),
                        obj.m_needs_libdirs.end() );
    }
    return deque_to_string( remove_double_entries_keep_first( libdirs ), "-L", " -L", "" );
}

string
SCOREP_Config_LibraryDependencies::getRpathFlags( const deque<string>& libs,
                                                  bool                 install )
{
    deque<string>           deps = get_dependencies( libs );
    deque<string>           libdirs;
    deque<string>::iterator i;
    for ( i = deps.begin(); i != deps.end(); i++ )
    {
        const LibraryData& obj = m_library_objects[ *i ];
        if ( !install )
        {
            libdirs.push_back( obj.m_build_dir + "/.libs" );
        }
        libdirs.push_back( obj.m_install_dir );
        libdirs.insert( libdirs.end(),
                        obj.m_needs_libdirs.begin(),
                        obj.m_needs_libdirs.end() );
    }
    AppendLdRunPath( libdirs );
    return deque_to_string( remove_double_entries_keep_first( libdirs ),
                            m_rpath_head + m_rpath_delimiter,
                            m_rpath_delimiter,
                            m_rpath_tail );
}

deque<string>
SCOREP_Config_LibraryDependencies::getLibdirs( const deque<string>& libs,
                                               bool                 install,
                                               bool                 honorLibs,
                                               bool                 honorDeps )
{
    deque<string>                 deps = get_dependencies( libs, honorLibs, honorDeps );
    deque<string>                 libdirs;
    deque<string>::const_iterator i;
    for ( i = deps.begin(); i != deps.end(); i++ )
    {
        const LibraryData& obj = m_library_objects[ *i ];
        if ( !install )
        {
            libdirs.push_back( obj.m_build_dir + "/.libs" );
        }
        libdirs.push_back( obj.m_install_dir );
        libdirs.insert( libdirs.end(),
                        obj.m_needs_libdirs.begin(),
                        obj.m_needs_libdirs.end() );
    }
    return remove_double_entries_keep_first( libdirs );
}

deque<string>
SCOREP_Config_LibraryDependencies::get_dependencies( const deque<string>& libs,
                                                     bool                 honorLibs,
                                                     bool                 honorDeps )
{
    if ( !honorDeps )
    {
        return libs;
    }

    deque<string> deps = libs;
    for ( int i = 0; i < deps.size(); i++ )
    {
        if ( m_library_objects.find( deps[ i ] ) == m_library_objects.end() )
        {
            cerr << "[Score-P] ERROR: Cannot resolve dependency '" << deps[ i ] << "'" << endl;
            exit( EXIT_FAILURE );
        }
        const LibraryData& obj = m_library_objects[ deps[ i ] ];

        deps.insert( deps.end(),
                     obj.m_dependencies.begin(),
                     obj.m_dependencies.end() );
    }
    deps = remove_double_entries_keep_last( deps );

    if ( !honorLibs )
    {
        deps.erase( deps.begin(), deps.begin() + libs.size() );
    }
    return deps;
}

void
SCOREP_Config_LibraryDependencies::addDependency( const std::string& dependentLib,
                                                  const std::string& dependency )
{
    if ( m_library_objects.find( dependentLib ) == m_library_objects.end() )
    {
        cerr << "[Score-P] ERROR: Cannot add dependency to '" << dependentLib << "'" << endl;
        exit( EXIT_FAILURE );
    }
    if ( m_library_objects.find( dependency ) == m_library_objects.end() )
    {
        cerr << "[Score-P] ERROR: Cannot add dependency '" << dependency << "'" << endl;
        exit( EXIT_FAILURE );
    }

    m_library_objects[ dependentLib ].m_dependencies.push_back( dependency );
}

std::deque<std::string>
SCOREP_Config_LibraryDependencies::RemoveSystemPath( const std::deque<std::string>& paths )
{
    std::string             dlsearch_path = SCOREP_BACKEND_SYS_LIB_DLSEARCH_PATH;
    std::deque<std::string> system_paths  = string_to_deque( dlsearch_path, " " );
    std::deque<std::string> result_paths;

    std::deque<std::string>::iterator       sys_path;
    std::deque<std::string>::const_iterator app_path;

    for ( app_path = paths.begin(); app_path != paths.end(); app_path++ )
    {
        bool is_sys_path = false;
        for ( sys_path = system_paths.begin();
              sys_path != system_paths.end(); sys_path++ )
        {
            if ( *app_path == *sys_path )
            {
                is_sys_path = true;
            }
        }
        if ( !is_sys_path )
        {
            result_paths.push_back( *app_path );
        }
    }
    return result_paths;
}

void
SCOREP_Config_LibraryDependencies::AppendLdRunPath( std::deque<std::string>& paths )
{
    /* Get variable values */
    const char* ld_run_path_env = getenv( "LD_RUN_PATH" ); // abs_dir[:abs_dir]
    if ( ld_run_path_env == NULL || *ld_run_path_env == '\0' )
    {
        return;
    }

    std::deque<std::string> ld_run_path = string_to_deque( ld_run_path_env, ":" );
    ld_run_path = remove_double_entries_keep_first( ld_run_path );
    ld_run_path = RemoveSystemPath( ld_run_path );
    /* Omit empty entries, entries that are not absolute paths, and
     * those that contain whitespace. */
    for ( const auto& i : ld_run_path )
    {
        if ( i.empty()
             || i[ 0 ] != '/'
             || i.find_first_of( "\t\n " ) != string::npos )
        {
            continue;
        }
        paths.push_back( i );
    }
}

static std::string
get_rpath_flag()
{
    // Replace $wl by LIBDIR_FLAG_WL and erase everything from
    // $libdir on in order to create m_rpath_head and
    // m_rpath_delimiter. This will work for most and for the relevant
    // (as we know in 2012-07) values of LIBDIR_FLAG_CC. Some possible
    // values are (see also ticket 530,
    // https://silc.zih.tu-dresden.de/trac-silc/ticket/530):
    // '+b $libdir'
    // '-L$libdir'
    // '-R$libdir'
    // '-rpath $libdir'
    // '$wl-blibpath:$libdir:'"$aix_libpath"
    // '$wl+b $wl$libdir'
    // '$wl-R,$libdir'
    // '$wl-R $libdir:/usr/lib:/lib'
    // '$wl-rpath,$libdir'
    // '$wl--rpath $wl$libdir'
    // '$wl-rpath $wl$libdir'
    // '$wl-R $wl$libdir'
    // For a complete list, check the currently used libtool.m4.
    std::string            rpath_flag = LIBDIR_FLAG_CC;
    std::string::size_type index      = 0;
    while ( true )
    {
        index = rpath_flag.find( "$wl", index );
        if ( index == std::string::npos )
        {
            break;
        }
        rpath_flag.replace( index, strlen( "$wl" ), LIBDIR_FLAG_WL );
        ++index;
    }
    index = rpath_flag.find( "$libdir", 0 );
    if ( index != std::string::npos )
    {
        rpath_flag.erase( index );
    }
    return rpath_flag;
}

#if HAVE( PLATFORM_AIX )
std::string SCOREP_Config_LibraryDependencies::m_rpath_head      = " " + get_rpath_flag();
std::string SCOREP_Config_LibraryDependencies::m_rpath_delimiter = ":";
std::string SCOREP_Config_LibraryDependencies::m_rpath_tail      = ":" LIBDIR_AIX_LIBPATH;
#else
std::string SCOREP_Config_LibraryDependencies::m_rpath_head;
std::string SCOREP_Config_LibraryDependencies::m_rpath_delimiter = " " + get_rpath_flag();
std::string SCOREP_Config_LibraryDependencies::m_rpath_tail;
#endif
