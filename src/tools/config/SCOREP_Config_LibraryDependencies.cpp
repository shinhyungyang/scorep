/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2013,
 * RWTH Aachen University, Germany
 *
 * Copyright (c) 2009-2013,
 * Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *
 * Copyright (c) 2009-2013, 2016-2017, 2024,
 * Technische Universitaet Dresden, Germany
 *
 * Copyright (c) 2009-2013,
 * University of Oregon, Eugene, USA
 *
 * Copyright (c) 2009-2013, 2017, 2024,
 * Forschungszentrum Juelich GmbH, Germany
 *
 * Copyright (c) 2009-2014,
 * German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *
 * Copyright (c) 2009-2013,
 * Technische Universitaet Muenchen, Germany
 *
 * This software may be modified and distributed under the terms of
 * a BSD-style license.  See the COPYING file in the package base
 * directory for details.
 */

/**
 * @file
 *
 * Implements the representation and analysis of library dependencies
 */

#include <config.h>

#include <iostream>
#include <stdlib.h>
#include <cstring>

#include "SCOREP_Config_LibraryDependencies.hpp"

#include <scorep_tools_utils.hpp>
#include <scorep_config_tool_backend.h>

using namespace std;

/* config-external-libs-<AFS_BUILD_name>.hpp are generated by
 * build-config/common/Makefile-rpaths.inc.am, see the
 * $(CONFIG_EXTERNAL_LIBS_HPP) target.
 */

#include <config-external-libs-backend.hpp>
#if HAVE( MPI_SUPPORT )
#include <config-external-libs-mpi_backend.hpp>
#endif /* MPI_SUPPORT */
#if HAVE( SHMEM_SUPPORT )
#include <config-external-libs-shmem_backend.hpp>
#endif /* SHMEM_SUPPORT */
#include <config-external-libs-score.hpp>

/* **************************************************************************************
                                                  class SCOREP_Config_LibraryDependencies
****************************************************************************************/

SCOREP_Config_LibraryDependencies::SCOREP_Config_LibraryDependencies( void )
{
    add_library_dependencies_backend( &m_library_objects );
    #if HAVE( MPI_SUPPORT )
    add_library_dependencies_mpi_backend( &m_library_objects );
    #endif /* MPI_SUPPORT */
    #if HAVE( SHMEM_SUPPORT )
    add_library_dependencies_shmem_backend( &m_library_objects );
    #endif /* SHMEM_SUPPORT */
    add_library_dependencies_score( &m_library_objects );
}

void
SCOREP_Config_LibraryDependencies::insert( const string& libName,
                                           const string& libInstallDir )
{
    /* Do not remove known linker and loader search paths from libInstallDir
       here, but in the getLDFlags() and getRpathFlags() methods. */
    m_library_objects.insert(
        make_pair( libName,
                   LibraryData( libName,
                                "",         // buildDir of no use for libwrapped lib
                                libInstallDir,
                                "", ""      // libwrapped libs are supposed to be self-contained
                                ) ) );
}

deque<string>
SCOREP_Config_LibraryDependencies::getLibraries( const deque<string>& inputLibs,
                                                 bool                 honorLibs,
                                                 bool                 honorDeps )
{
    /* Traversing backwards will add the -l flags from the scorep_* lib last.
       this makes the system more robust against broken dependencies in installed
       .la files of other libraries, in particular libbfd.
       During configure we tested whether linking works and this is more reliable
       than installed .la files. */
    deque<string>                   deps = get_dependencies( inputLibs, true, honorDeps );
    deque<string>                   libs;
    deque<string>::reverse_iterator i;
    for ( i = deps.rbegin(); i != deps.rend(); i++ )
    {
        const LibraryData& obj = m_library_objects[ *i ];
        libs.push_front( "-l" + obj.m_lib_name.substr( 3 ) );
        if ( honorDeps )
        {
            libs.insert( libs.end(),
                         obj.m_needs_libs.begin(),
                         obj.m_needs_libs.end() );
        }
    }

    libs = remove_double_entries_keep_last( libs );

    if ( !honorLibs )
    {
        libs.erase( libs.begin(), libs.begin() + inputLibs.size() );
    }

    return libs;
}

string
SCOREP_Config_LibraryDependencies::getLDFlags( const deque<string>& libs,
                                               bool                 install )
{
    return deque_to_string( remove_linker_search_paths(
                                get_libdirs( get_dependencies( libs ), install ) ),
                            "-L", " -L", "" );
}

string
SCOREP_Config_LibraryDependencies::getRpathFlags( const deque<string>& libs,
                                                  bool                 install )
{
    deque<string> libdirs( remove_loader_search_paths(
                               get_libdirs( get_dependencies( libs ), install ) ) );
    append_ld_run_path( libdirs );
    return deque_to_string( libdirs,
                            m_rpath_head + m_rpath_delimiter,
                            m_rpath_delimiter,
                            m_rpath_tail );
}

deque<string>
SCOREP_Config_LibraryDependencies::getLibdirs( const deque<string>& libs,
                                               bool                 install,
                                               bool                 honorLibs,
                                               bool                 honorDeps )
{
    return get_libdirs( get_dependencies( libs, honorLibs, honorDeps ), install );
}

deque<string>
SCOREP_Config_LibraryDependencies::get_libdirs( const deque<string> libs,
                                                bool                install )
{
    deque<string> libdirs;
    for ( auto& i : libs )
    {
        const LibraryData& obj = m_library_objects[ i ];
        if ( !install )
        {
            libdirs.push_back( obj.m_build_dir + "/.libs" );
        }
        if ( !obj.m_install_dir.empty() )
        {
            libdirs.push_back( obj.m_install_dir );
        }
        libdirs.insert( libdirs.end(),
                        obj.m_needs_libdirs.begin(),
                        obj.m_needs_libdirs.end() );
    }
    return remove_double_entries_keep_first( libdirs );
}

deque<string>
SCOREP_Config_LibraryDependencies::get_dependencies( const deque<string>& libs,
                                                     bool                 honorLibs,
                                                     bool                 honorDeps )
{
    if ( !honorDeps )
    {
        return libs;
    }

    /* Iterate over container of libs and implicit dependencies and
       append element's dependencies to the container until there is
       nothing to add left. */
    deque<string> deps( libs );
    deps.insert( deps.end(), m_implicit_dependencies.begin(), m_implicit_dependencies.end() );
    for ( int i = 0; i < deps.size(); i++ ) /* deps.size() intended to increase */
    {
        if ( m_library_objects.find( deps[ i ] ) == m_library_objects.end() )
        {
            cerr << "[Score-P] ERROR: Cannot resolve dependency '" << deps[ i ] << "'" << endl;
            exit( EXIT_FAILURE );
        }
        const LibraryData& obj = m_library_objects[ deps[ i ] ];

        deps.insert( deps.end(),
                     obj.m_dependencies.begin(),
                     obj.m_dependencies.end() );
    }
    deps = remove_double_entries_keep_last( deps );

    if ( !honorLibs )
    {
        /* Remove the libs and implicit dependencies we started with. */
        deps.erase( deps.begin(), deps.begin() + libs.size() + m_implicit_dependencies.size() );
    }
    return deps;
}

void
SCOREP_Config_LibraryDependencies::addDependency( const string& dependentLib,
                                                  const string& dependency )
{
    if ( m_library_objects.find( dependentLib ) == m_library_objects.end() )
    {
        cerr << "[Score-P] ERROR: Cannot add dependency to '" << dependentLib << "'" << endl;
        exit( EXIT_FAILURE );
    }
    if ( m_library_objects.find( dependency ) == m_library_objects.end() )
    {
        cerr << "[Score-P] ERROR: Cannot add dependency '" << dependency << "'" << endl;
        exit( EXIT_FAILURE );
    }

    m_library_objects[ dependentLib ].m_dependencies.push_back( dependency );
}

void
SCOREP_Config_LibraryDependencies::addImplicitDependency( const string& library )
{
    if ( m_library_objects.find( library ) == m_library_objects.end() )
    {
        cerr << "[Score-P] ERROR: Cannot add implicit dependency '" << library << "'" << endl;
        exit( EXIT_FAILURE );
    }
    m_implicit_dependencies.push_back( library );
}

deque<string>
SCOREP_Config_LibraryDependencies::remove_linker_search_paths( const deque<string>& input )
{
    return remove_paths( input,
                         string_to_deque( SCOREP_BACKEND_SYS_LIB_SEARCH_PATH, " " ) );
}

deque<string>
SCOREP_Config_LibraryDependencies::remove_loader_search_paths( const deque<string>& input )
{
    return remove_paths( input,
                         string_to_deque( SCOREP_BACKEND_SYS_LIB_DLSEARCH_PATH, " " ) );
}

deque<string>
SCOREP_Config_LibraryDependencies::remove_paths( const deque<string>& input,
                                                 const deque<string>& remove )
{
    deque<string> result_paths;

    for ( deque<string>::const_iterator input_path = input.begin();
          input_path != input.end(); input_path++ )
    {
        bool is_remove_path = false;
        for ( deque<string>::const_iterator remove_path = remove.begin();
              remove_path != remove.end(); remove_path++ )
        {
            if ( *input_path == *remove_path )
            {
                is_remove_path = true;
            }
        }
        if ( !is_remove_path )
        {
            result_paths.push_back( *input_path );
        }
    }
    return result_paths;
}

void
SCOREP_Config_LibraryDependencies::append_ld_run_path( deque<string>& paths )
{
    /* Get variable values */
    const char* ld_run_path_env = getenv( "LD_RUN_PATH" ); // abs_dir[:abs_dir]
    if ( ld_run_path_env == NULL || *ld_run_path_env == '\0' )
    {
        return;
    }

    deque<string> ld_run_path = string_to_deque( ld_run_path_env, ":" );
    ld_run_path = remove_double_entries_keep_first( ld_run_path );
    ld_run_path = remove_loader_search_paths( ld_run_path );
    /* Omit empty entries, entries that are not absolute paths, and
     * those that contain whitespace. */
    for ( const auto& i : ld_run_path )
    {
        if ( i.empty()
             || i[ 0 ] != '/'
             || i.find_first_of( "\t\n " ) != string::npos )
        {
            cerr << "[Score-P] WARNING: Omitting implausible LD_RUN_PATH element '"
                 << i << "'." << endl;
            continue;
        }
        paths.push_back( i );
    }
}

static string
get_rpath_flag()
{
    // Replace $wl by LIBDIR_FLAG_WL and erase everything from
    // $libdir on in order to create m_rpath_head and
    // m_rpath_delimiter. This will work for most and for the relevant
    // (as we know in 2012-07) values of LIBDIR_FLAG_CC. Some possible
    // values are (see also ticket 530,
    // https://silc.zih.tu-dresden.de/trac-silc/ticket/530):
    // '+b $libdir'
    // '-L$libdir'
    // '-R$libdir'
    // '-rpath $libdir'
    // '$wl-blibpath:$libdir:'"$aix_libpath"
    // '$wl+b $wl$libdir'
    // '$wl-R,$libdir'
    // '$wl-R $libdir:/usr/lib:/lib'
    // '$wl-rpath,$libdir'
    // '$wl--rpath $wl$libdir'
    // '$wl-rpath $wl$libdir'
    // '$wl-R $wl$libdir'
    // For a complete list, check the currently used libtool.m4.
    string            rpath_flag = LIBDIR_FLAG_CC;
    string::size_type index      = 0;
    while ( true )
    {
        index = rpath_flag.find( "$wl", index );
        if ( index == string::npos )
        {
            break;
        }
        rpath_flag.replace( index, strlen( "$wl" ), LIBDIR_FLAG_WL );
        ++index;
    }
    index = rpath_flag.find( "$libdir", 0 );
    if ( index != string::npos )
    {
        rpath_flag.erase( index );
    }
    return rpath_flag;
}

#if HAVE( PLATFORM_AIX )
string SCOREP_Config_LibraryDependencies::m_rpath_head      = " " + get_rpath_flag();
string SCOREP_Config_LibraryDependencies::m_rpath_delimiter = ":";
string SCOREP_Config_LibraryDependencies::m_rpath_tail      = ":" LIBDIR_AIX_LIBPATH;
#else
string SCOREP_Config_LibraryDependencies::m_rpath_head;
string SCOREP_Config_LibraryDependencies::m_rpath_delimiter = " " + get_rpath_flag();
string SCOREP_Config_LibraryDependencies::m_rpath_tail;
#endif
