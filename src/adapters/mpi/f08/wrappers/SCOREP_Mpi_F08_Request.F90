!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Request.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief C wrappers for request handling
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Cancel in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CANCEL) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CANCEL ) && HAVE_F08_TS_BUFFERS_MPI_CANCEL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CANCEL( &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Cancel

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(IN) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_scorep_req

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CANCEL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    local_scorep_req = scorep_mpi_request_get(request)
    call scorep_mpi_request_set_cancel(local_scorep_req)
    call scorep_mpi_unmark_request(local_scorep_req)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cancel( &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Request_free in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REQUEST_FREE) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REQUEST_FREE ) && HAVE_F08_TS_BUFFERS_MPI_REQUEST_FREE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REQUEST_FREE( &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_REQUEST_NULL, &
        PMPI_Request_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(INOUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: local_got_null_request

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REQUEST_FREE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    local_got_null_request = (request .eq. MPI_REQUEST_NULL)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_request_free_wrapper(request)
    if (request .ne. MPI_REQUEST_NULL .or. local_got_null_request) then
        call scorep_enter_wrapped_region(scorep_in_measurement_save)
        call PMPI_Request_free( &
            request, &
            internal_ierror)
        call scorep_exit_wrapped_region(scorep_in_measurement_save)

    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Request_get_status in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REQUEST_GET_STATUS) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REQUEST_GET_STATUS ) && HAVE_F08_TS_BUFFERS_MPI_REQUEST_GET_STATUS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REQUEST_GET_STATUS( &
    request, &
    flag, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        PMPI_Request_get_status

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(IN) :: request
    LOGICAL, INTENT(OUT) :: flag
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled
    type(c_ptr) :: local_scorep_req

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REQUEST_GET_STATUS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Request_get_status( &
        request, &
        flag, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    local_scorep_req = scorep_mpi_request_get(request)
    if (flag) then
        call scorep_mpi_check_request(local_scorep_req, internal_status)
        call scorep_mpi_request_set_completed(local_scorep_req)
    else if (event_gen_active_for_group .and. xreqtest_enabled) then
        call scorep_mpi_request_tested(local_scorep_req)
    end if
    call scorep_mpi_unmark_request(local_scorep_req)
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Start in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_START) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_START ) && HAVE_F08_TS_BUFFERS_MPI_START )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_START( &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Start

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(INOUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_START)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_request_start(request)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Start( &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Startall in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_STARTALL) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_STARTALL ) && HAVE_F08_TS_BUFFERS_MPI_STARTALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_STARTALL( &
    count, &
    array_of_requests, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Startall

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_REQUEST), DIMENSION(COUNT), INTENT(INOUT) :: array_of_requests
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer :: local_i

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_STARTALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            do local_i = 1, count
                call scorep_mpi_request_start(array_of_requests(local_i))
            end do
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Startall( &
        count, &
        array_of_requests, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Test in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TEST) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TEST ) && HAVE_F08_TS_BUFFERS_MPI_TEST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TEST( &
    request, &
    flag, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        PMPI_Test

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(INOUT) :: request
    LOGICAL, INTENT(OUT) :: flag
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TEST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(request)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Test( &
        request, &
        flag, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active_for_group .and. xreqtest_enabled) then
        call scorep_mpi_check_all_or_test_all(1, flag, internal_status)
    else
        call scorep_mpi_check_all_or_none(1, flag, internal_status)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Test_cancelled in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TEST_CANCELLED) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TEST_CANCELLED ) && HAVE_F08_TS_BUFFERS_MPI_TEST_CANCELLED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TEST_CANCELLED( &
    status, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_STATUS, &
        PMPI_Test_cancelled

    implicit none

! Dummy argument declarations
    TYPE(MPI_STATUS), INTENT(IN) :: status
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TEST_CANCELLED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Test_cancelled( &
        status, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Testall in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TESTALL) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TESTALL ) && HAVE_F08_TS_BUFFERS_MPI_TESTALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TESTALL( &
    count, &
    array_of_requests, &
    flag, &
    array_of_statuses, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        PMPI_Testall

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_REQUEST), DIMENSION(COUNT), INTENT(INOUT) :: array_of_requests
    LOGICAL, INTENT(OUT) :: flag
    TYPE(MPI_STATUS), DIMENSION(*), TARGET :: array_of_statuses
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), DIMENSION(:), POINTER :: internal_array_of_statuses
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TESTALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_statuses_ignore(array_of_statuses)) then
        call c_f_pointer(scorep_mpi_get_status_array(int(count, c_size_t)), &
                         internal_array_of_statuses, &
                         shape=[count])
    else
        internal_array_of_statuses => array_of_statuses(:count)
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(array_of_requests)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Testall( &
        count, &
        array_of_requests, &
        flag, &
        internal_array_of_statuses, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active_for_group .and. xreqtest_enabled) then
        call scorep_mpi_check_all_or_test_all(count, flag, internal_array_of_statuses)
    else
        call scorep_mpi_check_all_or_none(count, flag, internal_array_of_statuses)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Testany in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TESTANY) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TESTANY ) && HAVE_F08_TS_BUFFERS_MPI_TESTANY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TESTANY( &
    count, &
    array_of_requests, &
    index, &
    flag, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        MPI_UNDEFINED, &
        PMPI_Testany

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_REQUEST), DIMENSION(COUNT), INTENT(INOUT) :: array_of_requests
    INTEGER, INTENT(OUT) :: index
    LOGICAL, INTENT(OUT) :: flag
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TESTANY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(array_of_requests)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Testany( &
        count, &
        array_of_requests, &
        index, &
        flag, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (.not. flag) then
        ! array_of_requests contains active handles, but none were completed
        if (event_gen_active_for_group .and. xreqtest_enabled) then
            call scorep_mpi_test_all(count)
        end if
    else if (index .ne. MPI_UNDEFINED) then
        ! array_of_requests contains active handles, and one was completed
        if (event_gen_active_for_group .and. xreqtest_enabled) then
            call scorep_mpi_check_some_test_some(count, 1, index, internal_status)
        else
            call scorep_mpi_check_some(count, 1, index, internal_status)
        end if
    end if
    ! else, array_of_requests contains no active handles
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Testsome in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TESTSOME) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TESTSOME ) && HAVE_F08_TS_BUFFERS_MPI_TESTSOME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TESTSOME( &
    incount, &
    array_of_requests, &
    outcount, &
    array_of_indices, &
    array_of_statuses, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        MPI_UNDEFINED, &
        PMPI_Testsome

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: incount
    TYPE(MPI_REQUEST), DIMENSION(INCOUNT), INTENT(INOUT) :: array_of_requests
    INTEGER, INTENT(OUT) :: outcount
    INTEGER, DIMENSION(*), INTENT(OUT) :: array_of_indices
    TYPE(MPI_STATUS), DIMENSION(*), TARGET :: array_of_statuses
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), DIMENSION(:), POINTER :: internal_array_of_statuses
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TESTSOME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_statuses_ignore(array_of_statuses)) then
        call c_f_pointer(scorep_mpi_get_status_array(int(incount, c_size_t)), &
                         internal_array_of_statuses, &
                         shape=[incount])
    else
        internal_array_of_statuses => array_of_statuses(:incount)
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(array_of_requests)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Testsome( &
        incount, &
        array_of_requests, &
        outcount, &
        array_of_indices, &
        internal_array_of_statuses, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (outcount .ne. MPI_UNDEFINED) then
        ! array_of_requests contains active handles
        if (event_gen_active_for_group .and. xreqtest_enabled) then
            call scorep_mpi_check_some_test_some(incount, outcount, array_of_indices, internal_array_of_statuses)
        else
            call scorep_mpi_check_some(incount, outcount, array_of_indices, internal_array_of_statuses)
        end if
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Wait in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WAIT) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WAIT ) && HAVE_F08_TS_BUFFERS_MPI_WAIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WAIT( &
    request, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        PMPI_Wait

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(INOUT) :: request
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WAIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(request)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Wait( &
        request, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    call scorep_mpi_check_all_or_none(1, .true., internal_status)
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Waitall in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WAITALL) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WAITALL ) && HAVE_F08_TS_BUFFERS_MPI_WAITALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WAITALL( &
    count, &
    array_of_requests, &
    array_of_statuses, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        PMPI_Waitall

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_REQUEST), DIMENSION(COUNT), INTENT(INOUT) :: array_of_requests
    TYPE(MPI_STATUS), DIMENSION(*), TARGET :: array_of_statuses
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), DIMENSION(:), POINTER :: internal_array_of_statuses
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WAITALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_statuses_ignore(array_of_statuses)) then
        call c_f_pointer(scorep_mpi_get_status_array(int(count, c_size_t)), &
                         internal_array_of_statuses, &
                         shape=[count])
    else
        internal_array_of_statuses => array_of_statuses(:count)
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(array_of_requests)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Waitall( &
        count, &
        array_of_requests, &
        internal_array_of_statuses, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    call scorep_mpi_check_all_or_none(count, .true., internal_array_of_statuses)
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Waitany in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WAITANY) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WAITANY ) && HAVE_F08_TS_BUFFERS_MPI_WAITANY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WAITANY( &
    count, &
    array_of_requests, &
    index, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        MPI_UNDEFINED, &
        PMPI_Waitany

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_REQUEST), DIMENSION(COUNT), INTENT(INOUT) :: array_of_requests
    INTEGER, INTENT(OUT) :: index
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WAITANY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(array_of_requests)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Waitany( &
        count, &
        array_of_requests, &
        index, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (index .ne. MPI_UNDEFINED) then
        ! array_of_requests contains active handles
        if (event_gen_active_for_group .and. xreqtest_enabled) then
            call scorep_mpi_check_some_test_some(count, 1, index, internal_status)
        else
            call scorep_mpi_check_some(count, 1, index, internal_status)
        end if
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Waitsome in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup request
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WAITSOME) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WAITSOME ) && HAVE_F08_TS_BUFFERS_MPI_WAITSOME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WAITSOME( &
    incount, &
    array_of_requests, &
    outcount, &
    array_of_indices, &
    array_of_statuses, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        MPI_STATUS, &
        MPI_UNDEFINED, &
        PMPI_Waitsome

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: incount
    TYPE(MPI_REQUEST), DIMENSION(INCOUNT), INTENT(INOUT) :: array_of_requests
    INTEGER, INTENT(OUT) :: outcount
    INTEGER, DIMENSION(*), INTENT(OUT) :: array_of_indices
    TYPE(MPI_STATUS), DIMENSION(*), TARGET :: array_of_statuses
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), DIMENSION(:), POINTER :: internal_array_of_statuses
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: xreqtest_enabled

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WAITSOME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    xreqtest_enabled = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_XREQTEST) .gt. 0))
    if (scorep_mpi_is_statuses_ignore(array_of_statuses)) then
        call c_f_pointer(scorep_mpi_get_status_array(int(incount, c_size_t)), &
                         internal_array_of_statuses, &
                         shape=[incount])
    else
        internal_array_of_statuses => array_of_statuses(:incount)
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_save_request_array(array_of_requests)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Waitsome( &
        incount, &
        array_of_requests, &
        outcount, &
        array_of_indices, &
        internal_array_of_statuses, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (outcount .ne. MPI_UNDEFINED) then
        ! array_of_requests contains active handles
        if (event_gen_active_for_group .and. xreqtest_enabled) then
            call scorep_mpi_check_some_test_some(incount, outcount, array_of_indices, internal_array_of_statuses)
        else
            call scorep_mpi_check_some(incount, outcount, array_of_indices, internal_array_of_statuses)
        end if
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Parrived in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup request
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PARRIVED) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PARRIVED ) && HAVE_F08_TS_BUFFERS_MPI_PARRIVED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PARRIVED( &
    request, &
    partition, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Parrived

    implicit none

! Dummy argument declarations
    TYPE(MPI_REQUEST), INTENT(IN) :: request
    INTEGER, INTENT(IN) :: partition
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PARRIVED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Parrived( &
        request, &
        partition, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pready in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup request
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PREADY) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PREADY ) && HAVE_F08_TS_BUFFERS_MPI_PREADY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PREADY( &
    partition, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Pready

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: partition
    TYPE(MPI_REQUEST), INTENT(IN) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PREADY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pready( &
        partition, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pready_list in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup request
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PREADY_LIST) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PREADY_LIST ) && HAVE_F08_TS_BUFFERS_MPI_PREADY_LIST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PREADY_LIST( &
    length, &
    array_of_partitions, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Pready_list

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: length
    INTEGER, DIMENSION(LENGTH), INTENT(IN) :: array_of_partitions
    TYPE(MPI_REQUEST), INTENT(IN) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PREADY_LIST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pready_list( &
        length, &
        array_of_partitions, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pready_range in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup request
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PREADY_RANGE) && !defined(SCOREP_MPI_NO_REQUEST)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PREADY_RANGE ) && HAVE_F08_TS_BUFFERS_MPI_PREADY_RANGE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PREADY_RANGE( &
    partition_low, &
    partition_high, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_REQUEST, &
        PMPI_Pready_range

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: partition_low
    INTEGER, INTENT(IN) :: partition_high
    TYPE(MPI_REQUEST), INTENT(IN) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PREADY_RANGE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_REQUEST)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pready_range( &
        partition_low, &
        partition_high, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
