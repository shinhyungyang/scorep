!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Cg.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for communicator and group functions
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Comm_compare in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_COMPARE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_COMPARE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_COMPARE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_COMPARE( &
    comm1, &
    comm2, &
    result, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_compare

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm1
    TYPE(MPI_COMM), INTENT(IN) :: comm2
    INTEGER, INTENT(OUT) :: result
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_COMPARE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_compare( &
        comm1, &
        comm2, &
        result, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE( &
    comm, &
    group, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_GROUP, &
        PMPI_Comm_create

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_GROUP), INTENT(IN) :: group
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_create( &
        comm, &
        group, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_create_group in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_GROUP)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_GROUP ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_GROUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_GROUP( &
    comm, &
    group, &
    tag, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_GROUP, &
        PMPI_Comm_create_group

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CREATE_GROUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_create_group( &
        comm, &
        group, &
        tag, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            else
                ! The communicator creation was a local operation, hence we use MPI_COMM_SELF for the collective
                local_new_comm_handle = scorep_mpi_comm_handle(MPI_COMM_SELF)
            end if
            call SCOREP_MpiCollectiveEnd(local_new_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_dup in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_DUP)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_DUP ) && HAVE_F08_TS_BUFFERS_MPI_COMM_DUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_DUP( &
    comm, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Comm_dup

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_DUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_dup( &
        comm, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_dup_with_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_DUP_WITH_INFO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_DUP_WITH_INFO ) && HAVE_F08_TS_BUFFERS_MPI_COMM_DUP_WITH_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_DUP_WITH_INFO( &
    comm, &
    info, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Comm_dup_with_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_DUP_WITH_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_dup_with_info( &
        comm, &
        info, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_free in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_FREE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_FREE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_FREE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_FREE( &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(INOUT) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_FREE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_comm_free(comm)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_free( &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_CommDestroy(local_comm_handle)
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_DESTROY_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_group in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_GROUP)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_GROUP ) && HAVE_F08_TS_BUFFERS_MPI_COMM_GROUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_GROUP( &
    comm, &
    group, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Comm_group

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_GROUP), INTENT(OUT) :: group
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_GROUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_group( &
        comm, &
        group, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (group .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(group)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_idup in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_IDUP)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_IDUP ) && HAVE_F08_TS_BUFFERS_MPI_COMM_IDUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_IDUP( &
    comm, &
    newcomm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Comm_idup

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_COMM), INTENT(OUT), ASYNCHRONOUS :: newcomm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_IDUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_idup( &
        comm, &
        newcomm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .ne. MPI_SUCCESS) then
        call scorep_mpi_request_comm_idup_create(request, comm, newcomm, local_request_id)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_rank in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_RANK) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_MINI) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_RANK ) && HAVE_F08_TS_BUFFERS_MPI_COMM_RANK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_RANK( &
    comm, &
    rank, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_rank

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: rank
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_RANK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_rank( &
        comm, &
        rank, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_remote_group in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_REMOTE_GROUP)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_REMOTE_GROUP ) && HAVE_F08_TS_BUFFERS_MPI_COMM_REMOTE_GROUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_REMOTE_GROUP( &
    comm, &
    group, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Comm_remote_group

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_GROUP), INTENT(OUT) :: group
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_REMOTE_GROUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_remote_group( &
        comm, &
        group, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (group .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(group)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_remote_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_REMOTE_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_MINI) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_REMOTE_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_REMOTE_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_REMOTE_SIZE( &
    comm, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_remote_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_REMOTE_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_remote_size( &
        comm, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_MINI) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SIZE( &
    comm, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_size( &
        comm, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_split in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPLIT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SPLIT ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SPLIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPLIT( &
    comm, &
    color, &
    key, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Comm_split

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: color
    INTEGER, INTENT(IN) :: key
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SPLIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_split( &
        comm, &
        color, &
        key, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_split_type in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPLIT_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SPLIT_TYPE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SPLIT_TYPE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPLIT_TYPE( &
    comm, &
    split_type, &
    key, &
    info, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Comm_split_type

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: split_type
    INTEGER, INTENT(IN) :: key
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SPLIT_TYPE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_split_type( &
        comm, &
        split_type, &
        key, &
        info, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_test_inter in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_TEST_INTER) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_TEST_INTER ) && HAVE_F08_TS_BUFFERS_MPI_COMM_TEST_INTER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_TEST_INTER( &
    comm, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_test_inter

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_TEST_INTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_test_inter( &
        comm, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_compare in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_COMPARE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_COMPARE ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_COMPARE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_COMPARE( &
    group1, &
    group2, &
    result, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        PMPI_Group_compare

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group1
    TYPE(MPI_GROUP), INTENT(IN) :: group2
    INTEGER, INTENT(OUT) :: result
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_COMPARE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_compare( &
        group1, &
        group2, &
        result, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_difference in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_DIFFERENCE) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_DIFFERENCE ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_DIFFERENCE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_DIFFERENCE( &
    group1, &
    group2, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_difference

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group1
    TYPE(MPI_GROUP), INTENT(IN) :: group2
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_DIFFERENCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_difference( &
        group1, &
        group2, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_excl in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_EXCL) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_EXCL ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_EXCL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_EXCL( &
    group, &
    n, &
    ranks, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_excl

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: n
    INTEGER, DIMENSION(N), INTENT(IN) :: ranks
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_EXCL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_excl( &
        group, &
        n, &
        ranks, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_free in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_FREE) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_FREE ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_FREE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_FREE( &
    group, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        PMPI_Group_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(INOUT) :: group
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_FREE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_group_free(group)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_free( &
        group, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_incl in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_INCL) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_INCL ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_INCL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_INCL( &
    group, &
    n, &
    ranks, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_incl

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: n
    INTEGER, DIMENSION(N), INTENT(IN) :: ranks
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_INCL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_incl( &
        group, &
        n, &
        ranks, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_intersection in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_INTERSECTION) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_INTERSECTION ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_INTERSECTION )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_INTERSECTION( &
    group1, &
    group2, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_intersection

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group1
    TYPE(MPI_GROUP), INTENT(IN) :: group2
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_INTERSECTION)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_intersection( &
        group1, &
        group2, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_range_excl in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_RANGE_EXCL) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_RANGE_EXCL ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_RANGE_EXCL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_RANGE_EXCL( &
    group, &
    n, &
    ranges, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_range_excl

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: n
    INTEGER, DIMENSION(3, N), INTENT(IN) :: ranges
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_RANGE_EXCL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_range_excl( &
        group, &
        n, &
        ranges, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_range_incl in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_RANGE_INCL) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_RANGE_INCL ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_RANGE_INCL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_RANGE_INCL( &
    group, &
    n, &
    ranges, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_range_incl

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: n
    INTEGER, DIMENSION(3, N), INTENT(IN) :: ranges
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_RANGE_INCL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_range_incl( &
        group, &
        n, &
        ranges, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_rank in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_RANK) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_RANK ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_RANK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_RANK( &
    group, &
    rank, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        PMPI_Group_rank

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(OUT) :: rank
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_RANK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_rank( &
        group, &
        rank, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_SIZE( &
    group, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        PMPI_Group_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_size( &
        group, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_translate_ranks in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_TRANSLATE_RANKS) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_TRANSLATE_RANKS ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_TRANSLATE_RANKS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_TRANSLATE_RANKS( &
    group1, &
    n, &
    ranks1, &
    group2, &
    ranks2, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        PMPI_Group_translate_ranks

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group1
    INTEGER, INTENT(IN) :: n
    INTEGER, DIMENSION(N), INTENT(IN) :: ranks1
    TYPE(MPI_GROUP), INTENT(IN) :: group2
    INTEGER, DIMENSION(N), INTENT(OUT) :: ranks2
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_TRANSLATE_RANKS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_translate_ranks( &
        group1, &
        n, &
        ranks1, &
        group2, &
        ranks2, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_union in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_UNION) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_UNION ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_UNION )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_UNION( &
    group1, &
    group2, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_Group_union

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group1
    TYPE(MPI_GROUP), INTENT(IN) :: group2
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_UNION)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_union( &
        group1, &
        group2, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Intercomm_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INTERCOMM_CREATE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INTERCOMM_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_INTERCOMM_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INTERCOMM_CREATE( &
    local_comm, &
    local_leader, &
    peer_comm, &
    remote_leader, &
    tag, &
    newintercomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Comm_rank, &
        PMPI_Intercomm_create

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: local_comm
    INTEGER, INTENT(IN) :: local_leader
    TYPE(MPI_COMM), INTENT(IN) :: peer_comm
    INTEGER, INTENT(IN) :: remote_leader
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(OUT) :: newintercomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle
    integer :: local_rank

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INTERCOMM_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(peer_comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Intercomm_create( &
        local_comm, &
        local_leader, &
        peer_comm, &
        remote_leader, &
        tag, &
        newintercomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newintercomm .ne. MPI_COMM_NULL) then
        ! The semantic of the peer communicator only requires a useful
        ! communicator on the respective local leader rank.
        ! To avoid unnecessary duplicates use MPI_COMM_NULL for all other
        ! ranks in the place of the parent/peer communicator.

        call PMPI_Comm_rank(local_comm, local_rank)
        if (local_leader .eq. local_rank) then
            local_new_comm_handle = scorep_mpi_comm_create(newintercomm, peer_comm)
        else
            local_new_comm_handle = scorep_mpi_comm_create(newintercomm, MPI_COMM_NULL)
        end if
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            else
                ! The communicator creation was a local operation, hence we use MPI_COMM_SELF for the collective
                local_new_comm_handle = scorep_mpi_comm_handle(MPI_COMM_SELF)
            end if
            call SCOREP_MpiCollectiveEnd(local_new_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Intercomm_merge in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INTERCOMM_MERGE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INTERCOMM_MERGE ) && HAVE_F08_TS_BUFFERS_MPI_INTERCOMM_MERGE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INTERCOMM_MERGE( &
    intercomm, &
    high, &
    newintracomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Intercomm_merge

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: intercomm
    LOGICAL, INTENT(IN) :: high
    TYPE(MPI_COMM), INTENT(OUT) :: newintracomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INTERCOMM_MERGE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(intercomm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Intercomm_merge( &
        intercomm, &
        high, &
        newintracomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newintracomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newintracomm, intercomm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_call_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CALL_ERRHANDLER) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CALL_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CALL_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CALL_ERRHANDLER( &
    comm, &
    errorcode, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_call_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: errorcode
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CALL_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_call_errhandler( &
        comm, &
        errorcode, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_create_keyval in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_KEYVAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_KEYVAL ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_KEYVAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_KEYVAL( &
    comm_copy_attr_fn, &
    comm_delete_attr_fn, &
    comm_keyval, &
    extra_state, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM_COPY_ATTR_FUNCTION, &
        MPI_COMM_DELETE_ATTR_FUNCTION, &
        PMPI_Comm_create_keyval

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_COMM_COPY_ATTR_FUNCTION) :: comm_copy_attr_fn
    PROCEDURE(MPI_COMM_DELETE_ATTR_FUNCTION) :: comm_delete_attr_fn
    INTEGER, INTENT(OUT) :: comm_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: extra_state
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CREATE_KEYVAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_create_keyval( &
        comm_copy_attr_fn, &
        comm_delete_attr_fn, &
        comm_keyval, &
        extra_state, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_create_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_ERRHANDLER) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_ERRHANDLER( &
    comm_errhandler_fn, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM_ERRHANDLER_FUNCTION, &
        MPI_ERRHANDLER, &
        PMPI_Comm_create_errhandler

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_COMM_ERRHANDLER_FUNCTION) :: comm_errhandler_fn
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CREATE_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_create_errhandler( &
        comm_errhandler_fn, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_delete_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_DELETE_ATTR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_DELETE_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_COMM_DELETE_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_DELETE_ATTR( &
    comm, &
    comm_keyval, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_delete_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: comm_keyval
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_DELETE_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_delete_attr( &
        comm, &
        comm_keyval, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_free_keyval in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_FREE_KEYVAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_FREE_KEYVAL ) && HAVE_F08_TS_BUFFERS_MPI_COMM_FREE_KEYVAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_FREE_KEYVAL( &
    comm_keyval, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Comm_free_keyval

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(INOUT) :: comm_keyval
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_FREE_KEYVAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_free_keyval( &
        comm_keyval, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_get_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_ATTR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_GET_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_COMM_GET_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_ATTR( &
    comm, &
    comm_keyval, &
    attribute_val, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        PMPI_Comm_get_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: comm_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: attribute_val
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_GET_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_get_attr( &
        comm, &
        comm_keyval, &
        attribute_val, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_get_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_ERRHANDLER) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_GET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_COMM_GET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_ERRHANDLER( &
    comm, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_ERRHANDLER, &
        PMPI_Comm_get_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_GET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_get_errhandler( &
        comm, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_get_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_INFO) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_GET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_COMM_GET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_INFO( &
    comm, &
    info_used, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_INFO, &
        PMPI_Comm_get_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(OUT) :: info_used
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_GET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_get_info( &
        comm, &
        info_used, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_get_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_NAME) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_GET_NAME ) && HAVE_F08_TS_BUFFERS_MPI_COMM_GET_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_NAME( &
    comm, &
    comm_name, &
    resultlen, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_MAX_OBJECT_NAME, &
        PMPI_Comm_get_name

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    CHARACTER(LEN=MPI_MAX_OBJECT_NAME), INTENT(OUT) :: comm_name
    INTEGER, INTENT(OUT) :: resultlen
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_GET_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_get_name( &
        comm, &
        comm_name, &
        resultlen, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_set_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_ATTR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SET_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SET_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_ATTR( &
    comm, &
    comm_keyval, &
    attribute_val, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        PMPI_Comm_set_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: comm_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: attribute_val
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SET_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_set_attr( &
        comm, &
        comm_keyval, &
        attribute_val, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_set_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_ERRHANDLER) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_ERRHANDLER( &
    comm, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_ERRHANDLER, &
        PMPI_Comm_set_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_set_errhandler( &
        comm, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_set_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup cg_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_INFO) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_INFO( &
    comm, &
    info, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_INFO, &
        PMPI_Comm_set_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_set_info( &
        comm, &
        info, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_set_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup cg_ext
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_NAME) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_CG) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SET_NAME ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SET_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SET_NAME( &
    comm, &
    comm_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_SUCCESS, &
        PMPI_Comm_set_name

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    CHARACTER(LEN=*), INTENT(IN) :: comm_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SET_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG_EXT) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_set_name( &
        comm, &
        comm_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .eq. MPI_SUCCESS) then
        call scorep_mpi_comm_set_name(comm, comm_name)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_idup_with_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_IDUP_WITH_INFO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_IDUP_WITH_INFO ) && HAVE_F08_TS_BUFFERS_MPI_COMM_IDUP_WITH_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_IDUP_WITH_INFO( &
    comm, &
    info, &
    newcomm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_INFO, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Comm_idup_with_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(OUT), ASYNCHRONOUS :: newcomm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_IDUP_WITH_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_idup_with_info( &
        comm, &
        info, &
        newcomm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .ne. MPI_SUCCESS) then
        call scorep_mpi_request_comm_idup_create(request, comm, newcomm, local_request_id)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_create_from_group in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_FROM_GROUP) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_FROM_GROUP ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CREATE_FROM_GROUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CREATE_FROM_GROUP( &
    group, &
    stringtag, &
    info, &
    errhandler, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_ERRHANDLER, &
        MPI_GROUP, &
        MPI_INFO, &
        PMPI_Comm_create_from_group

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    CHARACTER(LEN=*), INTENT(IN) :: stringtag
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CREATE_FROM_GROUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_create_from_group( &
        group, &
        stringtag, &
        info, &
        errhandler, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, MPI_COMM_NULL)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            else
                ! The communicator creation was a local operation, hence we use MPI_COMM_SELF for the collective
                local_new_comm_handle = scorep_mpi_comm_handle(MPI_COMM_SELF)
            end if
            call SCOREP_MpiCollectiveEnd(local_new_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Intercomm_create_from_groups in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INTERCOMM_CREATE_FROM_GROUPS) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INTERCOMM_CREATE_FROM_GROUPS ) && HAVE_F08_TS_BUFFERS_MPI_INTERCOMM_CREATE_FROM_GROUPS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INTERCOMM_CREATE_FROM_GROUPS( &
    local_group, &
    local_leader, &
    remote_group, &
    remote_leader, &
    stringtag, &
    info, &
    errhandler, &
    newintercomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_ERRHANDLER, &
        MPI_GROUP, &
        MPI_INFO, &
        PMPI_Intercomm_create_from_groups

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: local_group
    INTEGER, INTENT(IN) :: local_leader
    TYPE(MPI_GROUP), INTENT(IN) :: remote_group
    INTEGER, INTENT(IN) :: remote_leader
    CHARACTER(LEN=*), INTENT(IN) :: stringtag
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    TYPE(MPI_COMM), INTENT(OUT) :: newintercomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INTERCOMM_CREATE_FROM_GROUPS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Intercomm_create_from_groups( &
        local_group, &
        local_leader, &
        remote_group, &
        remote_leader, &
        stringtag, &
        info, &
        errhandler, &
        newintercomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newintercomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newintercomm, MPI_COMM_NULL)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            else
                ! The communicator creation was a local operation, hence we use MPI_COMM_SELF for the collective
                local_new_comm_handle = scorep_mpi_comm_handle(MPI_COMM_SELF)
            end if
            call SCOREP_MpiCollectiveEnd(local_new_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Group_from_session_pset in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup cg
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GROUP_FROM_SESSION_PSET) && !defined(SCOREP_MPI_NO_CG)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GROUP_FROM_SESSION_PSET ) && HAVE_F08_TS_BUFFERS_MPI_GROUP_FROM_SESSION_PSET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GROUP_FROM_SESSION_PSET( &
    session, &
    pset_name, &
    newgroup, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        MPI_SESSION, &
        PMPI_Group_from_session_pset

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    CHARACTER(LEN=*), INTENT(IN) :: pset_name
    TYPE(MPI_GROUP), INTENT(OUT) :: newgroup
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GROUP_FROM_SESSION_PSET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_CG) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Group_from_session_pset( &
        session, &
        pset_name, &
        newgroup, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newgroup .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(newgroup)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
