!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Io.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for parallel I/O
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_File_call_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_CALL_ERRHANDLER) && !defined(SCOREP_MPI_NO_IO) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_CALL_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_FILE_CALL_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_CALL_ERRHANDLER( &
    fh, &
    errorcode, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        PMPI_File_call_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER, INTENT(IN) :: errorcode
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_CALL_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_call_errhandler( &
        fh, &
        errorcode, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_close in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_CLOSE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_CLOSE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_CLOSE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_CLOSE( &
    fh, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_MODE_DELETE_ON_CLOSE, &
        MPI_SUCCESS, &
        PMPI_File_close, &
        PMPI_File_get_amode

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(INOUT) :: fh
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer :: local_amode
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_IoFileHandle) :: local_file

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_CLOSE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_RemoveHandle(SCOREP_IO_PARADIGM_MPI, fh)
            call PMPI_File_get_amode(fh, local_amode)
            call SCOREP_IoMgmt_PushHandle(local_io_handle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_close( &
        fh, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoMgmt_PopHandle(local_io_handle)
                if (internal_ierror .ne. MPI_SUCCESS) then
                    if (iand(local_amode, MPI_MODE_DELETE_ON_CLOSE) .gt. 0) then
                        local_file = SCOREP_IoHandleHandle_GetIoFile(local_io_handle)
                        call SCOREP_IoDeleteFile(SCOREP_IO_PARADIGM_MPI, local_file)
                    end if
                    call SCOREP_IoDestroyHandle(local_io_handle)
                    call SCOREP_IoMgmt_DestroyHandle(local_io_handle)
                else
                    call SCOREP_IoMgmt_ReinsertHandle(SCOREP_IO_PARADIGM_MPI, local_io_handle)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_create_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_CREATE_ERRHANDLER) && !defined(SCOREP_MPI_NO_IO) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_CREATE_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_FILE_CREATE_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_CREATE_ERRHANDLER( &
    file_errhandler_fn, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_FILE_ERRHANDLER_FUNCTION, &
        PMPI_File_create_errhandler

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_FILE_ERRHANDLER_FUNCTION) :: file_errhandler_fn
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_CREATE_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_create_errhandler( &
        file_errhandler_fn, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_delete in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_DELETE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_DELETE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_DELETE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_DELETE( &
    filename, &
    info, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        PMPI_File_delete

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: filename
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoFileHandle) :: local_file

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_DELETE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_file = SCOREP_INVALID_IO_FILE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_file = SCOREP_IoMgmt_GetIoFileHandle(filename)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_delete( &
        filename, &
        info, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_file .ne. SCOREP_INVALID_IO_FILE) then
                call SCOREP_IoDeleteFile(SCOREP_IO_PARADIGM_MPI, local_file)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_amode in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_AMODE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_AMODE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_AMODE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_AMODE( &
    fh, &
    amode, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        PMPI_File_get_amode

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER, INTENT(OUT) :: amode
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_AMODE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_amode( &
        fh, &
        amode, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_atomicity in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_ATOMICITY) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_ATOMICITY ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_ATOMICITY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_ATOMICITY( &
    fh, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        PMPI_File_get_atomicity

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_ATOMICITY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_atomicity( &
        fh, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_byte_offset in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_BYTE_OFFSET) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_BYTE_OFFSET ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_BYTE_OFFSET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_BYTE_OFFSET( &
    fh, &
    offset, &
    disp, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_byte_offset

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: disp
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_BYTE_OFFSET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_byte_offset( &
        fh, &
        offset, &
        disp, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_ERRHANDLER) && !defined(SCOREP_MPI_NO_IO) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_ERRHANDLER( &
    file, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_FILE, &
        PMPI_File_get_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: file
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_errhandler( &
        file, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_group in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_GROUP) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_GROUP ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_GROUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_GROUP( &
    fh, &
    group, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        PMPI_File_get_group

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    TYPE(MPI_GROUP), INTENT(OUT) :: group
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_GROUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_group( &
        fh, &
        group, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (group .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(group)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_INFO) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_INFO( &
    fh, &
    info_used, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_INFO, &
        PMPI_File_get_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    TYPE(MPI_INFO), INTENT(OUT) :: info_used
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_info( &
        fh, &
        info_used, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_position in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_POSITION) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_POSITION ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_POSITION )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_POSITION( &
    fh, &
    offset, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_position

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: offset
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_POSITION)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_position( &
        fh, &
        offset, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_position_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_POSITION_SHARED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_POSITION_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_POSITION_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_POSITION_SHARED( &
    fh, &
    offset, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_position_shared

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: offset
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_POSITION_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_position_shared( &
        fh, &
        offset, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_SIZE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_SIZE( &
    fh, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_size( &
        fh, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_type_extent in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_TYPE_EXTENT) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_TYPE_EXTENT ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_TYPE_EXTENT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_TYPE_EXTENT( &
    fh, &
    datatype, &
    extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        PMPI_File_get_type_extent

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_TYPE_EXTENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_type_extent( &
        fh, &
        datatype, &
        extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_type_extent in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_TYPE_EXTENT_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_TYPE_EXTENT_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_TYPE_EXTENT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_TYPE_EXTENT_C( &
    fh, &
    datatype, &
    extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        PMPI_File_get_type_extent

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_TYPE_EXTENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_type_extent( &
        fh, &
        datatype, &
        extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_get_view in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_VIEW) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_GET_VIEW ) && HAVE_F08_TS_BUFFERS_MPI_FILE_GET_VIEW )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_GET_VIEW( &
    fh, &
    disp, &
    etype, &
    filetype, &
    datarep, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_view

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: disp
    TYPE(MPI_DATATYPE), INTENT(OUT) :: etype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: filetype
    CHARACTER(LEN=*), INTENT(OUT) :: datarep
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_GET_VIEW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_get_view( &
        fh, &
        disp, &
        etype, &
        filetype, &
        datarep, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.1
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_ALL( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_ALL_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_at

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_at

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.1
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT_ALL( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_at_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_AT_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_AT_ALL_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_at_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_SHARED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_SHARED( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_shared

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iread_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_SHARED_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_SHARED_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IREAD_SHARED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IREAD_SHARED_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iread_shared

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IREAD_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iread_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_READ, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.1
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_ALL( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_ALL_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_at

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_at

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.1
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT_ALL( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_at_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_AT_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_AT_ALL_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_at_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_SHARED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_SHARED( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_shared

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_iwrite_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_SHARED_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_SHARED_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_IWRITE_SHARED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_IWRITE_SHARED_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_File_iwrite_shared

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_IWRITE_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_iwrite_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
                call scorep_mpi_request_io_create(request, &
                                                  SCOREP_IO_OPERATION_MODE_WRITE, &
                                                  count * local_datatype_size, &
                                                  datatype, &
                                                  fh, &
                                                  local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_open in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_OPEN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_OPEN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_OPEN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_OPEN( &
    comm, &
    filename, &
    amode, &
    info, &
    fh, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_FILE, &
        MPI_INFO, &
        MPI_SUCCESS, &
        PMPI_File_open

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    CHARACTER(LEN=*), INTENT(IN) :: filename
    INTEGER, INTENT(IN) :: amode
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_FILE), INTENT(OUT) :: fh
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int32_t) :: local_unify_key
    integer(SCOREP_IoFileHandle) :: local_file
    integer(SCOREP_IoHandleHandle) :: local_io_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_OPEN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_unify_key = 0_c_int32_t
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_comm_handle = scorep_mpi_comm_handle(comm)
            local_unify_key = scorep_mpi_io_get_unify_key(local_comm_handle)
            call SCOREP_IoMgmt_BeginHandleCreation(SCOREP_IO_PARADIGM_MPI, &
                                                   SCOREP_IO_HANDLE_FLAG_NONE, &
                                                   local_comm_handle, &
                                                   "")
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_open( &
        comm, &
        filename, &
        amode, &
        info, &
        fh, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                local_file = SCOREP_IoMgmt_GetIoFileHandle(filename)
                local_io_handle = SCOREP_IoMgmt_CompleteHandleCreation(SCOREP_IO_PARADIGM_MPI, local_file, local_unify_key, fh)
                if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                    call SCOREP_IoCreateHandle(local_io_handle, &
                                               scorep_mpi_io_get_access_mode(amode), &
                                               scorep_mpi_io_get_creation_flags(amode), &
                                               scorep_mpi_io_get_status_flags(amode))
                end if
            else
                call SCOREP_IoMgmt_DropIncompleteHandle()
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_preallocate in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_PREALLOCATE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_PREALLOCATE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_PREALLOCATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_PREALLOCATE( &
    fh, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_preallocate

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_PREALLOCATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_preallocate( &
        fh, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_BEGIN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_BEGIN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_BEGIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_BEGIN( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_read_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_all_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_BEGIN_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_BEGIN_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_BEGIN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_BEGIN_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_read_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_all_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_all_end in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_END) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_END ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ALL_END )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ALL_END( &
    fh, &
    buf, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE_NULL, &
        MPI_Datatype, &
        MPI_FILE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        PMPI_File_read_all_end, &
        PMPI_Get_count, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer :: local_count
    type(MPI_Datatype) :: local_datatype
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ALL_END)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    local_datatype = MPI_DATATYPE_NULL
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_all_end( &
        fh, &
        buf, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_end(local_io_handle, local_request_id, local_datatype)
                call PMPI_Get_count(internal_status, local_datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * get_datatype_size(local_datatype), &
                                                local_request_id)
#if ( defined( HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP ) && HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP )
                call PMPI_Type_free(local_datatype)
#endif
            end if

            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_read_at, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_read_at, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_read_at_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_read_at_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_BEGIN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_BEGIN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_BEGIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_BEGIN( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_SUCCESS, &
        PMPI_File_read_at_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at_all_begin( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_BEGIN_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_BEGIN_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_BEGIN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_BEGIN_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_SUCCESS, &
        PMPI_File_read_at_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at_all_begin( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_at_all_end in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_END) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_END ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_AT_ALL_END )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_AT_ALL_END( &
    fh, &
    buf, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE_NULL, &
        MPI_Datatype, &
        MPI_FILE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        PMPI_File_read_at_all_end, &
        PMPI_Get_count, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer :: local_count
    type(MPI_Datatype) :: local_datatype
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_AT_ALL_END)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    local_datatype = MPI_DATATYPE_NULL
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_at_all_end( &
        fh, &
        buf, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_end(local_io_handle, local_request_id, local_datatype)
                call PMPI_Get_count(internal_status, local_datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * get_datatype_size(local_datatype), &
                                                local_request_id)
#if ( defined( HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP ) && HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP )
                call PMPI_Type_free(local_datatype)
#endif
            end if

            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_ordered in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read_ordered, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ORDERED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_ordered( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_ordered in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read_ordered, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ORDERED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_ordered( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_ordered_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_BEGIN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_BEGIN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_BEGIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_BEGIN( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_read_ordered_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ORDERED_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_ordered_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_ordered_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_BEGIN_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_BEGIN_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_BEGIN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_BEGIN_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_read_ordered_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ORDERED_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_ordered_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_ordered_end in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_END) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_END ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_ORDERED_END )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_ORDERED_END( &
    fh, &
    buf, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE_NULL, &
        MPI_Datatype, &
        MPI_FILE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        PMPI_File_read_ordered_end, &
        PMPI_Get_count, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer :: local_count
    type(MPI_Datatype) :: local_datatype
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_ORDERED_END)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    local_datatype = MPI_DATATYPE_NULL
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_ordered_end( &
        fh, &
        buf, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_end(local_io_handle, local_request_id, local_datatype)
                call PMPI_Get_count(internal_status, local_datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * get_datatype_size(local_datatype), &
                                                local_request_id)
#if ( defined( HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP ) && HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP )
                call PMPI_Type_free(local_datatype)
#endif
            end if

            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_SHARED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_SHARED( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read_shared, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_read_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_SHARED_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_READ_SHARED_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_READ_SHARED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_READ_SHARED_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_read_shared, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_READ_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_READ, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_read_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_READ, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_seek in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SEEK) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SEEK ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SEEK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SEEK( &
    fh, &
    offset, &
    whence, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_position, &
        PMPI_File_seek

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    INTEGER, INTENT(IN) :: whence
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(MPI_OFFSET_KIND) :: local_pos

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SEEK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_seek( &
        fh, &
        offset, &
        whence, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_File_get_position(fh, local_pos)

                call SCOREP_IoSeek(local_io_handle, &
                                   offset, &
                                   scorep_mpi_io_get_seek_option(whence), &
                                   local_pos)

                call SCOREP_IoMgmt_PopHandle(local_io_handle)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_seek_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SEEK_SHARED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SEEK_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SEEK_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SEEK_SHARED( &
    fh, &
    offset, &
    whence, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_get_position, &
        PMPI_File_seek_shared

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    INTEGER, INTENT(IN) :: whence
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(MPI_OFFSET_KIND) :: local_pos

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SEEK_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_seek_shared( &
        fh, &
        offset, &
        whence, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_File_get_position(fh, local_pos)

                call SCOREP_IoSeek(local_io_handle, &
                                   offset, &
                                   scorep_mpi_io_get_seek_option(whence), &
                                   local_pos)

                call SCOREP_IoMgmt_PopHandle(local_io_handle)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_set_atomicity in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_ATOMICITY) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SET_ATOMICITY ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SET_ATOMICITY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_ATOMICITY( &
    fh, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        PMPI_File_set_atomicity

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    LOGICAL, INTENT(IN) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SET_ATOMICITY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_set_atomicity( &
        fh, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_set_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_ERRHANDLER) && !defined(SCOREP_MPI_NO_IO) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_ERRHANDLER( &
    file, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_FILE, &
        PMPI_File_set_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: file
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO_ERR) &
    &.gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_set_errhandler( &
        file, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_set_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_INFO) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_INFO( &
    fh, &
    info, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_INFO, &
        PMPI_File_set_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_set_info( &
        fh, &
        info, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_set_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_SIZE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SET_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SET_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_SIZE( &
    fh, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        PMPI_File_set_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SET_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_set_size( &
        fh, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_set_view in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_VIEW) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SET_VIEW ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SET_VIEW )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SET_VIEW( &
    fh, &
    disp, &
    etype, &
    filetype, &
    datarep, &
    info, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_INFO, &
        MPI_OFFSET_KIND, &
        PMPI_File_set_view

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: disp
    TYPE(MPI_DATATYPE), INTENT(IN) :: etype
    TYPE(MPI_DATATYPE), INTENT(IN) :: filetype
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SET_VIEW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_set_view( &
        fh, &
        disp, &
        etype, &
        filetype, &
        datarep, &
        info, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_sync in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_SYNC) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_SYNC ) && HAVE_F08_TS_BUFFERS_MPI_FILE_SYNC )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_SYNC( &
    fh, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_FILE, &
        PMPI_File_sync

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_SYNC)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_sync( &
        fh, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_all( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_BEGIN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_BEGIN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_BEGIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_BEGIN( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_write_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_all_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_BEGIN_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_BEGIN_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_BEGIN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_BEGIN_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_write_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_all_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_all_end in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_END) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_END ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ALL_END )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ALL_END( &
    fh, &
    buf, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE_NULL, &
        MPI_Datatype, &
        MPI_FILE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        PMPI_File_write_all_end, &
        PMPI_Get_count, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer :: local_count
    type(MPI_Datatype) :: local_datatype
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ALL_END)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    local_datatype = MPI_DATATYPE_NULL
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_all_end( &
        fh, &
        buf, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_end(local_io_handle, local_request_id, local_datatype)
                call PMPI_Get_count(internal_status, local_datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * get_datatype_size(local_datatype), &
                                                local_request_id)
#if ( defined( HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP ) && HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP )
                call PMPI_Type_free(local_datatype)
#endif
            end if

            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_write_at, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_write_at, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_write_at_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_STATUS, &
        PMPI_File_write_at_all, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at_all( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_BEGIN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_BEGIN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_BEGIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_BEGIN( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_SUCCESS, &
        PMPI_File_write_at_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at_all_begin( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at_all_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_BEGIN_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_BEGIN_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_BEGIN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_BEGIN_C( &
    fh, &
    offset, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_OFFSET_KIND, &
        MPI_SUCCESS, &
        PMPI_File_write_at_all_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: offset
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT_ALL_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             offset)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at_all_begin( &
        fh, &
        offset, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_at_all_end in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_END) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_END ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_AT_ALL_END )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_AT_ALL_END( &
    fh, &
    buf, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE_NULL, &
        MPI_Datatype, &
        MPI_FILE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        PMPI_File_write_at_all_end, &
        PMPI_Get_count, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer :: local_count
    type(MPI_Datatype) :: local_datatype
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_AT_ALL_END)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    local_datatype = MPI_DATATYPE_NULL
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_at_all_end( &
        fh, &
        buf, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_end(local_io_handle, local_request_id, local_datatype)
                call PMPI_Get_count(internal_status, local_datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * get_datatype_size(local_datatype), &
                                                local_request_id)
#if ( defined( HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP ) && HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP )
                call PMPI_Type_free(local_datatype)
#endif
            end if

            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_ordered in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write_ordered, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ORDERED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_ordered( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_ordered in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write_ordered, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ORDERED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_ordered( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_ordered_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_BEGIN) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_BEGIN ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_BEGIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_BEGIN( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_write_ordered_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ORDERED_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_ordered_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_ordered_begin in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_BEGIN_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_BEGIN_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_BEGIN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_BEGIN_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_SUCCESS, &
        PMPI_File_write_ordered_begin

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ORDERED_BEGIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_NON_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_ordered_begin( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_begin(local_io_handle, local_request_id, datatype)
                call SCOREP_IoOperationIssued(local_io_handle, local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_ordered_end in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_END) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_END ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_ORDERED_END )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_ORDERED_END( &
    fh, &
    buf, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE_NULL, &
        MPI_Datatype, &
        MPI_FILE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        PMPI_File_write_ordered_end, &
        PMPI_Get_count, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer :: local_count
    type(MPI_Datatype) :: local_datatype
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_ORDERED_END)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    local_datatype = MPI_DATATYPE_NULL
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_ordered_end( &
        fh, &
        buf, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS .and. local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call scorep_mpi_io_split_end(local_io_handle, local_request_id, local_datatype)
                call PMPI_Get_count(internal_status, local_datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * get_datatype_size(local_datatype), &
                                                local_request_id)
#if ( defined( HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP ) && HAVE_MPI_2_0_SYMBOL_PMPI_TYPE_DUP )
                call PMPI_Type_free(local_datatype)
#endif
            end if

            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_SHARED) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_SHARED( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write_shared, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_File_write_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_SHARED_C) && !defined(SCOREP_MPI_NO_IO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_SHARED_C ) && HAVE_F08_TS_BUFFERS_MPI_FILE_WRITE_SHARED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FILE_WRITE_SHARED_C( &
    fh, &
    buf, &
    count, &
    datatype, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_FILE, &
        MPI_STATUS, &
        PMPI_File_write_shared, &
        PMPI_Get_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_FILE), INTENT(IN) :: fh
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_datatype_size
    integer(SCOREP_IoHandleHandle) :: local_io_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(MPI_COUNT_KIND) :: local_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FILE_WRITE_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    local_datatype_size = 0_c_int64_t
    local_io_handle = SCOREP_INVALID_IO_HANDLE
    local_count = 0
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_datatype_size = get_datatype_size_c(datatype)
            local_io_handle = SCOREP_IoMgmt_GetAndPushHandle(SCOREP_IO_PARADIGM_MPI, fh)
            local_request_id = scorep_mpi_get_request_id()
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call SCOREP_IoOperationBegin(local_io_handle, &
                                             SCOREP_IO_OPERATION_MODE_WRITE, &
                                             iand(SCOREP_IO_OPERATION_FLAG_NON_COLLECTIVE, SCOREP_IO_OPERATION_FLAG_BLOCKING), &
                                             count * local_datatype_size, &
                                             local_request_id, &
                                             SCOREP_IO_UNKNOWN_OFFSET)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_File_write_shared( &
        fh, &
        buf, &
        count, &
        datatype, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_io_handle .ne. SCOREP_INVALID_IO_HANDLE) then
                call PMPI_Get_count(internal_status, datatype, local_count)
                call SCOREP_IoOperationComplete(local_io_handle, &
                                                SCOREP_IO_OPERATION_MODE_WRITE, &
                                                local_count * local_datatype_size, &
                                                local_request_id)
            end if
            call SCOREP_IoMgmt_PopHandle(local_io_handle)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Register_datarep in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REGISTER_DATAREP) && !defined(SCOREP_MPI_NO_IO) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REGISTER_DATAREP ) && HAVE_F08_TS_BUFFERS_MPI_REGISTER_DATAREP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REGISTER_DATAREP( &
    datarep, &
    read_conversion_fn, &
    write_conversion_fn, &
    dtype_file_extent_fn, &
    extra_state, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATAREP_CONVERSION_FUNCTION, &
        MPI_DATAREP_EXTENT_FUNCTION, &
        PMPI_Register_datarep

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    PROCEDURE(MPI_DATAREP_CONVERSION_FUNCTION) :: read_conversion_fn
    PROCEDURE(MPI_DATAREP_CONVERSION_FUNCTION) :: write_conversion_fn
    PROCEDURE(MPI_DATAREP_EXTENT_FUNCTION) :: dtype_file_extent_fn
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: extra_state
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REGISTER_DATAREP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Register_datarep( &
        datarep, &
        read_conversion_fn, &
        write_conversion_fn, &
        dtype_file_extent_fn, &
        extra_state, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Register_datarep_c in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup io
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REGISTER_DATAREP_C) && !defined(SCOREP_MPI_NO_IO) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REGISTER_DATAREP_C ) && HAVE_F08_TS_BUFFERS_MPI_REGISTER_DATAREP_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REGISTER_DATAREP_C( &
    datarep, &
    read_conversion_fn, &
    write_conversion_fn, &
    dtype_file_extent_fn, &
    extra_state, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATAREP_CONVERSION_FUNCTION_C, &
        MPI_DATAREP_EXTENT_FUNCTION, &
        PMPI_Register_datarep_c

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    PROCEDURE(MPI_DATAREP_CONVERSION_FUNCTION_C) :: read_conversion_fn
    PROCEDURE(MPI_DATAREP_CONVERSION_FUNCTION_C) :: write_conversion_fn
    PROCEDURE(MPI_DATAREP_EXTENT_FUNCTION) :: dtype_file_extent_fn
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: extra_state
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REGISTER_DATAREP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_IO) .gt.&
    & 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Register_datarep_c( &
        datarep, &
        read_conversion_fn, &
        write_conversion_fn, &
        dtype_file_extent_fn, &
        extra_state, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
