!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Coll.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for collective communication
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Allgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHER ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Allgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHER ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHER )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgather(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, &
            &local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER_C)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Allgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgather(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, &
            &local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Allgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgatherv(sendcount, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Allgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgatherv(sendcount, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allreduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE ) && HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Allreduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLREDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE ) && HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allreduce(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allreduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLREDUCE, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allreduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Allreduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLREDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allreduce(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allreduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLREDUCE, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALL ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Alltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALL ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALL )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoall(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, l&
            &ocal_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALL, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Alltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoall(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, l&
            &ocal_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALL, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Alltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallv(sendcounts, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Alltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallv(sendcounts, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Alltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: sendtypes
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLW, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Alltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: sendtypes
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLW, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Barrier in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BARRIER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BARRIER ) && HAVE_F08_TS_BUFFERS_MPI_BARRIER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BARRIER( &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Barrier

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BARRIER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_barrier(comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Barrier( &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_BARRIER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bcast in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BCAST) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BCAST ) && HAVE_F08_TS_BUFFERS_MPI_BCAST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BCAST( &
    buffer, &
    count, &
    datatype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Bcast

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buffer
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BCAST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_bcast(count, datatype, root, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bcast( &
        buffer, &
        count, &
        datatype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_BROADCAST, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bcast in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BCAST_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BCAST_C ) && HAVE_F08_TS_BUFFERS_MPI_BCAST_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BCAST_C( &
    buffer, &
    count, &
    datatype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Bcast

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buffer
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BCAST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_bcast(count, datatype, root, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bcast( &
        buffer, &
        count, &
        datatype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_BROADCAST, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Exscan in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_EXSCAN ) && HAVE_F08_TS_BUFFERS_MPI_EXSCAN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Exscan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_EXSCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_EXSCAN ) && HAVE_F08_TS_BUFFERS_MPI_EXSCAN )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_exscan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Exscan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_EXSCAN, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Exscan in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_EXSCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_EXSCAN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Exscan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_EXSCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_EXSCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_EXSCAN_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_exscan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Exscan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_EXSCAN, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gather in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHER ) && HAVE_F08_TS_BUFFERS_MPI_GATHER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Gather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHER ) && HAVE_F08_TS_BUFFERS_MPI_GATHER )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gather(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byte&
            &s, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_GATHER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gather in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_GATHER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Gather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_GATHER_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gather(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byte&
            &s, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_GATHER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHERV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHERV ) && HAVE_F08_TS_BUFFERS_MPI_GATHERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHERV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Gatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHERV ) && HAVE_F08_TS_BUFFERS_MPI_GATHERV )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gatherv(sendcount, sendtype, recvcounts, recvtype, root, local_in_place, comm, local_send_by&
            &tes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_GATHERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHERV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_GATHERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHERV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Gatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_GATHERV_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gatherv(sendcount, sendtype, recvcounts, recvtype, root, local_in_place, comm, local_send_by&
            &tes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_GATHERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iallgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHER ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iallgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHER ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHER )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgather(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, &
            &local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iallgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iallgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iallgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHER_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgather(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, &
            &local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iallgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iallgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHERV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHERV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iallgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgatherv(sendcount, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iallgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHERV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iallgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHERV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLGATHERV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iallgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLGATHERV_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allgatherv(sendcount, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iallgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHERV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iallreduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLREDUCE) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE ) && HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLREDUCE( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iallreduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLREDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE ) && HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allreduce(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iallreduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLREDUCE, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iallreduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLREDUCE_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLREDUCE_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iallreduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLREDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLREDUCE_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_allreduce(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iallreduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLREDUCE, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ialltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALL) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALL ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALL( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ialltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALL ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALL )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoall(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, l&
            &ocal_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ialltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALL, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ialltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALL_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALL_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALL_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ialltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALL_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALL_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoall(sendcount, sendtype, recvcount, recvtype, local_in_place, comm, local_send_bytes, l&
            &ocal_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ialltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALL, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ialltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLV( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ialltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallv(sendcounts, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ialltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ialltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLV_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ialltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLV_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallv(sendcounts, sendtype, recvcounts, recvtype, local_in_place, comm, local_send_bytes&
            &, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ialltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ialltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLW) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLW( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ialltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ialltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLW, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ialltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLW_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IALLTOALLW_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ialltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW_C ) && HAVE_F08_TS_BUFFERS_MPI_IALLTOALLW_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ialltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLW, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ibarrier in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IBARRIER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IBARRIER ) && HAVE_F08_TS_BUFFERS_MPI_IBARRIER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IBARRIER( &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ibarrier

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IBARRIER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_barrier(comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ibarrier( &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_BARRIER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ibcast in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IBCAST) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IBCAST ) && HAVE_F08_TS_BUFFERS_MPI_IBCAST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IBCAST( &
    buffer, &
    count, &
    datatype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ibcast

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buffer
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IBCAST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_bcast(count, datatype, root, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ibcast( &
        buffer, &
        count, &
        datatype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_BROADCAST, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ibcast in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IBCAST_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IBCAST_C ) && HAVE_F08_TS_BUFFERS_MPI_IBCAST_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IBCAST_C( &
    buffer, &
    count, &
    datatype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ibcast

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buffer
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IBCAST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_bcast(count, datatype, root, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ibcast( &
        buffer, &
        count, &
        datatype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_BROADCAST, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iexscan in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IEXSCAN) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IEXSCAN ) && HAVE_F08_TS_BUFFERS_MPI_IEXSCAN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IEXSCAN( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iexscan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IEXSCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IEXSCAN ) && HAVE_F08_TS_BUFFERS_MPI_IEXSCAN )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_exscan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iexscan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_EXSCAN, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iexscan in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IEXSCAN_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IEXSCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_IEXSCAN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IEXSCAN_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iexscan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IEXSCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IEXSCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_IEXSCAN_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_exscan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iexscan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_EXSCAN, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Igather in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IGATHER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHER ) && HAVE_F08_TS_BUFFERS_MPI_IGATHER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IGATHER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Igather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHER ) && HAVE_F08_TS_BUFFERS_MPI_IGATHER )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gather(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byte&
            &s, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Igather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_GATHER, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Igather in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IGATHER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_IGATHER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IGATHER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Igather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_IGATHER_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gather(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byte&
            &s, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Igather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_GATHER, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Igatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IGATHERV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_IGATHERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IGATHERV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Igatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_IGATHERV )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gatherv(sendcount, sendtype, recvcounts, recvtype, root, local_in_place, comm, local_send_by&
            &tes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Igatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_GATHERV, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Igatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IGATHERV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_IGATHERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IGATHERV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Igatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_IGATHERV_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_gatherv(sendcount, sendtype, recvcounts, recvtype, root, local_in_place, comm, local_send_by&
            &tes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Igatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_GATHERV, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ireduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ireduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IREDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce(count, datatype, root, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ireduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_REDUCE, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ireduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ireduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IREDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce(count, datatype, root, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ireduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_REDUCE, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ireduce_scatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER( &
    sendbuf, &
    recvbuf, &
    recvcounts, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ireduce_scatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IREDUCE_SCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter(recvcounts, datatype, local_in_place, comm, local_send_bytes, local_recv_byte&
            &s)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ireduce_scatter( &
        sendbuf, &
        recvbuf, &
        recvcounts, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_REDUCE_SCATTER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ireduce_scatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER_C( &
    sendbuf, &
    recvbuf, &
    recvcounts, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ireduce_scatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IREDUCE_SCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter(recvcounts, datatype, local_in_place, comm, local_send_bytes, local_recv_byte&
            &s)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ireduce_scatter( &
        sendbuf, &
        recvbuf, &
        recvcounts, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_REDUCE_SCATTER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ireduce_scatter_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER_BLOCK) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER_BLOCK( &
    sendbuf, &
    recvbuf, &
    recvcount, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ireduce_scatter_block

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IREDUCE_SCATTER_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter_block(recvcount, datatype, local_in_place, comm, local_send_bytes, local_recv&
            &_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ireduce_scatter_block( &
        sendbuf, &
        recvbuf, &
        recvcount, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_REDUCE_SCATTER_BLOCK, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ireduce_scatter_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER_BLOCK_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK_C ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IREDUCE_SCATTER_BLOCK_C( &
    sendbuf, &
    recvbuf, &
    recvcount, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ireduce_scatter_block

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IREDUCE_SCATTER_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK_C ) && HAVE_F08_TS_BUFFERS_MPI_IREDUCE_SCATTER_BLOCK_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter_block(recvcount, datatype, local_in_place, comm, local_send_bytes, local_recv&
            &_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ireduce_scatter_block( &
        sendbuf, &
        recvbuf, &
        recvcount, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_REDUCE_SCATTER_BLOCK, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iscan in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISCAN) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCAN ) && HAVE_F08_TS_BUFFERS_MPI_ISCAN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISCAN( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iscan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCAN ) && HAVE_F08_TS_BUFFERS_MPI_ISCAN )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_scan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iscan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_SCAN, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iscan in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISCAN_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_ISCAN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISCAN_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iscan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_ISCAN_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_scan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iscan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_SCAN, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iscatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISCATTER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTER ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISCATTER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iscatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTER ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTER )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatter(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iscatter( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_SCATTER, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iscatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISCATTER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISCATTER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iscatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTER_C )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatter(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iscatter( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_SCATTER, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iscatterv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISCATTERV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTERV ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISCATTERV( &
    sendbuf, &
    sendcounts, &
    displs, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iscatterv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISCATTERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTERV ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTERV )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatterv(sendcounts, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_b&
            &ytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iscatterv( &
        sendbuf, &
        sendcounts, &
        displs, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_SCATTERV, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iscatterv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISCATTERV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTERV_C ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISCATTERV_C( &
    sendbuf, &
    sendcounts, &
    displs, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Iscatterv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISCATTERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISCATTERV_C ) && HAVE_F08_TS_BUFFERS_MPI_ISCATTERV_C )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatterv(sendcounts, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_b&
            &ytes, local_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iscatterv( &
        sendbuf, &
        sendcounts, &
        displs, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_SCATTERV, &
                                                     root, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce(count, datatype, root, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_REDUCE, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce(count, datatype, root, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_REDUCE, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_local in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.2
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_LOCAL) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_LOCAL ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_LOCAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_LOCAL( &
    inbuf, &
    inoutbuf, &
    count, &
    datatype, &
    op, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce_local

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    CHOICE_BUFFER_TYPE :: inoutbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_LOCAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_local( &
        inbuf, &
        inoutbuf, &
        count, &
        datatype, &
        op, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_local in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_LOCAL_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_LOCAL_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_LOCAL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_LOCAL_C( &
    inbuf, &
    inoutbuf, &
    count, &
    datatype, &
    op, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce_local

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    CHOICE_BUFFER_TYPE :: inoutbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_LOCAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_local( &
        inbuf, &
        inoutbuf, &
        count, &
        datatype, &
        op, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER( &
    sendbuf, &
    recvbuf, &
    recvcounts, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce_scatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter(recvcounts, datatype, local_in_place, comm, local_send_bytes, local_recv_byte&
            &s)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter( &
        sendbuf, &
        recvbuf, &
        recvcounts, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_REDUCE_SCATTER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_C( &
    sendbuf, &
    recvbuf, &
    recvcounts, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce_scatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter(recvcounts, datatype, local_in_place, comm, local_send_bytes, local_recv_byte&
            &s)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter( &
        sendbuf, &
        recvbuf, &
        recvcounts, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_REDUCE_SCATTER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.2
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK( &
    sendbuf, &
    recvbuf, &
    recvcount, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce_scatter_block

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter_block(recvcount, datatype, local_in_place, comm, local_send_bytes, local_recv&
            &_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter_block( &
        sendbuf, &
        recvbuf, &
        recvcount, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_REDUCE_SCATTER_BLOCK, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK_C( &
    sendbuf, &
    recvbuf, &
    recvcount, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Reduce_scatter_block

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_reduce_scatter_block(recvcount, datatype, local_in_place, comm, local_send_bytes, local_recv&
            &_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter_block( &
        sendbuf, &
        recvbuf, &
        recvcount, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_REDUCE_SCATTER_BLOCK, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scan in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCAN) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCAN ) && HAVE_F08_TS_BUFFERS_MPI_SCAN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCAN( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Scan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCAN ) && HAVE_F08_TS_BUFFERS_MPI_SCAN )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_scan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_SCAN, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scan in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCAN_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_SCAN_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCAN_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        PMPI_Scan

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCAN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCAN_C ) && HAVE_F08_TS_BUFFERS_MPI_SCAN_C )
            local_in_place = scorep_mpi_is_in_place_ts(sendbuf)
#else
            local_in_place = scorep_mpi_is_in_place(sendbuf)
#endif
            call scorep_mpi_coll_bytes_scan(count, datatype, local_in_place, comm, local_send_bytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scan( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_SCAN, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTER) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTER ) && HAVE_F08_TS_BUFFERS_MPI_SCATTER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Scatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTER ) && HAVE_F08_TS_BUFFERS_MPI_SCATTER )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatter(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatter( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_SCATTER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatter in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTER_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_SCATTER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Scatter

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTER_C ) && HAVE_F08_TS_BUFFERS_MPI_SCATTER_C )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatter(sendcount, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_byt&
            &es, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatter( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_SCATTER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatterv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTERV ) && HAVE_F08_TS_BUFFERS_MPI_SCATTERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV( &
    sendbuf, &
    sendcounts, &
    displs, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Scatterv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTERV ) && HAVE_F08_TS_BUFFERS_MPI_SCATTERV )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatterv(sendcounts, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_b&
            &ytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatterv( &
        sendbuf, &
        sendcounts, &
        displs, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_SCATTERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatterv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTERV_C ) && HAVE_F08_TS_BUFFERS_MPI_SCATTERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV_C( &
    sendbuf, &
    sendcounts, &
    displs, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Scatterv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTERV_C ) && HAVE_F08_TS_BUFFERS_MPI_SCATTERV_C )
            local_in_place = scorep_mpi_is_in_place_ts(recvbuf)
#else
            local_in_place = scorep_mpi_is_in_place(recvbuf)
#endif
            call scorep_mpi_coll_bytes_scatterv(sendcounts, sendtype, recvcount, recvtype, root, local_in_place, comm, local_send_b&
            &ytes, local_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatterv( &
        sendbuf, &
        sendcounts, &
        displs, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         scorep_mpi_get_scorep_mpi_rank(root), &
                                         SCOREP_COLLECTIVE_SCATTERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgather_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_INIT ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Allgather_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgather_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgather_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHER_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHER_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Allgather_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgather_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgatherv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Allgatherv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgatherv_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allgatherv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLGATHERV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLGATHERV_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Allgatherv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLGATHERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allgatherv_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allreduce_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_INIT ) && HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE_INIT( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Allreduce_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLREDUCE_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allreduce_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Allreduce_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLREDUCE_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLREDUCE_INIT_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Allreduce_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLREDUCE_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Allreduce_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoall_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_INIT ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Alltoall_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALL_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoall_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoall_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALL_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALL_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Alltoall_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALL_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoall_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV_INIT( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Alltoallv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallv_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLV_INIT_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Alltoallv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallv_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallw_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_INIT ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW_INIT( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Alltoallw_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLW_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallw_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Alltoallw_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_ALLTOALLW_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ALLTOALLW_INIT_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Alltoallw_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ALLTOALLW_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Alltoallw_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Barrier_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BARRIER_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BARRIER_INIT ) && HAVE_F08_TS_BUFFERS_MPI_BARRIER_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BARRIER_INIT( &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Barrier_init

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BARRIER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Barrier_init( &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bcast_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BCAST_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BCAST_INIT ) && HAVE_F08_TS_BUFFERS_MPI_BCAST_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BCAST_INIT( &
    buffer, &
    count, &
    datatype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Bcast_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buffer
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BCAST_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bcast_init( &
        buffer, &
        count, &
        datatype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bcast_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BCAST_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BCAST_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_BCAST_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BCAST_INIT_C( &
    buffer, &
    count, &
    datatype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Bcast_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buffer
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BCAST_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bcast_init( &
        buffer, &
        count, &
        datatype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Exscan_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_EXSCAN_INIT ) && HAVE_F08_TS_BUFFERS_MPI_EXSCAN_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN_INIT( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Exscan_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_EXSCAN_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Exscan_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Exscan_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_EXSCAN_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_EXSCAN_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_EXSCAN_INIT_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Exscan_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_EXSCAN_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Exscan_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gather_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHER_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHER_INIT ) && HAVE_F08_TS_BUFFERS_MPI_GATHER_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHER_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Gather_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gather_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gather_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHER_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHER_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_GATHER_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHER_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Gather_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gather_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gatherv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHERV_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHERV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_GATHERV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHERV_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Gatherv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gatherv_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Gatherv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GATHERV_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GATHERV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_GATHERV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GATHERV_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Gatherv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GATHERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Gatherv_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_INIT ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_INIT( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Reduce_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_INIT_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Reduce_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter_block_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_INIT ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK_INIT( &
    sendbuf, &
    recvbuf, &
    recvcount, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Reduce_scatter_block_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER_BLOCK_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter_block_init( &
        sendbuf, &
        recvbuf, &
        recvcount, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter_block_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_BLOCK_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_BLOCK_INIT_C( &
    sendbuf, &
    recvbuf, &
    recvcount, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Reduce_scatter_block_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER_BLOCK_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter_block_init( &
        sendbuf, &
        recvbuf, &
        recvcount, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_INIT ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_INIT( &
    sendbuf, &
    recvbuf, &
    recvcounts, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Reduce_scatter_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter_init( &
        sendbuf, &
        recvbuf, &
        recvcounts, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Reduce_scatter_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_REDUCE_SCATTER_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_REDUCE_SCATTER_INIT_C( &
    sendbuf, &
    recvbuf, &
    recvcounts, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Reduce_scatter_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_REDUCE_SCATTER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Reduce_scatter_init( &
        sendbuf, &
        recvbuf, &
        recvcounts, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scan_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCAN_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCAN_INIT ) && HAVE_F08_TS_BUFFERS_MPI_SCAN_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCAN_INIT( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Scan_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCAN_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scan_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scan_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCAN_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCAN_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_SCAN_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCAN_INIT_C( &
    sendbuf, &
    recvbuf, &
    count, &
    datatype, &
    op, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_OP, &
        MPI_REQUEST, &
        PMPI_Scan_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCAN_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scan_init( &
        sendbuf, &
        recvbuf, &
        count, &
        datatype, &
        op, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatter_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTER_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTER_INIT ) && HAVE_F08_TS_BUFFERS_MPI_SCATTER_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTER_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Scatter_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatter_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatter_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTER_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTER_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_SCATTER_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTER_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Scatter_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatter_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatterv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV_INIT) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTERV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_SCATTERV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV_INIT( &
    sendbuf, &
    sendcounts, &
    displs, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Scatterv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatterv_init( &
        sendbuf, &
        sendcounts, &
        displs, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Scatterv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup coll
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV_INIT_C) && !defined(SCOREP_MPI_NO_COLL)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SCATTERV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_SCATTERV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SCATTERV_INIT_C( &
    sendbuf, &
    sendcounts, &
    displs, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    root, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Scatterv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SCATTERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_COLL) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Scatterv_init( &
        sendbuf, &
        sendcounts, &
        displs, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        root, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
