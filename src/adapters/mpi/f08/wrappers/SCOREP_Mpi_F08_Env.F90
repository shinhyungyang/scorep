!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Env.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for environmental management
!>

#include <config.h>

module SCOREP_MPI_Env_globals
    logical :: mpi_finalize_called
end module

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Finalize in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup env
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FINALIZE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FINALIZE ) && HAVE_F08_TS_BUFFERS_MPI_FINALIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FINALIZE( &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM_SELF, &
        MPI_COMM_WORLD, &
        PMPI_Barrier, MPI_COMM_WORLD, MPI_SUCCESS, &
        PMPI_Finalize
    use :: SCOREP_MPI_Env_globals, only:mpi_finalize_called

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FINALIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

!Be so kind and name the MPI_COMM_WORLD communicator
!if the user didn't do so already
!
    call scorep_mpi_comm_set_default_names()
!Finalize event handling
!We need to make sure that our exit handler is called before the MPI handler
!
    call SCOREP_RegisterExitHandler()
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
!Fake finalization
!
    call PMPI_Barrier(MPI_COMM_WORLD, internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)
    if (internal_ierror .eq. MPI_SUCCESS) then
        mpi_finalize_called = .true.
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_CommDestroy(SCOREP_MPI_COMM_HANDLE(MPI_COMM_WORLD))
            call SCOREP_CommDestroy(SCOREP_MPI_COMM_HANDLE(MPI_COMM_SELF))
            call SCOREP_MpiCollectiveEnd(SCOREP_MPI_COMM_HANDLE(MPI_COMM_WORLD), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_DESTROY_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Finalized in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup env
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FINALIZED) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ENV)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FINALIZED ) && HAVE_F08_TS_BUFFERS_MPI_FINALIZED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FINALIZED( &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_SUCCESS, &
        PMPI_Finalized
    use :: SCOREP_MPI_Env_globals, only:mpi_finalize_called

    implicit none

! Dummy argument declarations
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FINALIZED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Finalized( &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .eq. MPI_SUCCESS .and. mpi_finalize_called) then
        flag = .true.
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Get_library_version in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GET_LIBRARY_VERSION) && !defined(SCOREP_MPI_NO_ENV)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GET_LIBRARY_VERSION ) && HAVE_F08_TS_BUFFERS_MPI_GET_LIBRARY_VERSION )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GET_LIBRARY_VERSION( &
    version, &
    resultlen, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_MAX_LIBRARY_VERSION_STRING, &
        PMPI_Get_library_version

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=MPI_MAX_LIBRARY_VERSION_STRING), INTENT(OUT) :: version
    INTEGER, INTENT(OUT) :: resultlen
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GET_LIBRARY_VERSION)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Get_library_version( &
        version, &
        resultlen, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Init in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup env
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INIT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INIT ) && HAVE_F08_TS_BUFFERS_MPI_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INIT( &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM_SELF, &
        MPI_COMM_WORLD, &
        MPI_SUCCESS, &
        MPI_THREAD_FUNNELED, &
        PMPI_Finalized, &
        PMPI_Init, &
        PMPI_Initialized
    use :: SCOREP_MPI_Env_globals, only:mpi_finalize_called

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: fflag
    logical :: iflag
    integer :: local_ierror

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    fflag = .false.
    iflag = .false.
    mpi_finalize_called = .false.
    if (logical(scorep_is_measurement_phase(SCOREP_MEASUREMENT_PHASE_PRE_C))) then
        call SCOREP_InitMeasurement()
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Init( &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .eq. MPI_SUCCESS) then
        call PMPI_Initialized(iflag, local_ierror)
        if (iflag .and. local_ierror .eq. MPI_SUCCESS) then
            call PMPI_Finalized(fflag, local_ierror)
            if (.not. fflag .and. local_ierror .eq. MPI_SUCCESS) then
                call SCOREP_InitMppMeasurement()
            end if
        end if
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_CommCreate(SCOREP_MPI_COMM_HANDLE(MPI_COMM_WORLD))
            call SCOREP_CommCreate(SCOREP_MPI_COMM_HANDLE(MPI_COMM_SELF))
            call SCOREP_MpiCollectiveEnd(SCOREP_MPI_COMM_HANDLE(MPI_COMM_WORLD), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Init_thread in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup env
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INIT_THREAD)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INIT_THREAD ) && HAVE_F08_TS_BUFFERS_MPI_INIT_THREAD )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INIT_THREAD( &
    required, &
    provided, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM_SELF, &
        MPI_COMM_WORLD, &
        MPI_SUCCESS, &
        MPI_THREAD_FUNNELED, &
        PMPI_Finalized, &
        PMPI_Init_thread, &
        PMPI_Initialized
    use :: SCOREP_MPI_Env_globals, only:mpi_finalize_called

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: required
    INTEGER, INTENT(OUT) :: provided
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    logical :: fflag
    logical :: iflag
    integer :: local_ierror

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INIT_THREAD)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    fflag = .false.
    iflag = .false.
    mpi_finalize_called = .false.
    if (logical(scorep_is_measurement_phase(SCOREP_MEASUREMENT_PHASE_PRE_C))) then
        call SCOREP_InitMeasurement()
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Init_thread( &
        required, &
        provided, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .eq. MPI_SUCCESS) then
        if ((required .gt. MPI_THREAD_FUNNELED) .and. (provided .gt. MPI_THREAD_FUNNELED)) then
            print *, "[Score-P] Warning: ", &
                "MPI environment initialization request and provided level exceed MPI_THREAD_FUNNELED!"

        end if
        if ((required .eq. MPI_THREAD_FUNNELED) .and. (provided .ge. MPI_THREAD_FUNNELED) &
            .and. (SCOREP_Location_GetId(SCOREP_Location_GetCurrentCPULocation()) .ne. 0)) then
            print *, "[Score-P] Warning: ", &
                "MPI environment initialization with MPI_THREAD_FUNNELED not on master thread!"

        end if
        call PMPI_Initialized(iflag, local_ierror)
        if (iflag .and. local_ierror .eq. MPI_SUCCESS) then
            call PMPI_Finalized(fflag, local_ierror)
            if (.not. fflag .and. local_ierror .eq. MPI_SUCCESS) then
                call SCOREP_InitMppMeasurement()
            end if
        end if
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_CommCreate(SCOREP_MPI_COMM_HANDLE(MPI_COMM_WORLD))
            call SCOREP_CommCreate(SCOREP_MPI_COMM_HANDLE(MPI_COMM_SELF))
            call SCOREP_MpiCollectiveEnd(SCOREP_MPI_COMM_HANDLE(MPI_COMM_WORLD), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Initialized in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup env
!> Events are only recorded inside the measurement phase.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INITIALIZED) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ENV)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INITIALIZED ) && HAVE_F08_TS_BUFFERS_MPI_INITIALIZED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INITIALIZED( &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Initialized

    implicit none

! Dummy argument declarations
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INITIALIZED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    event_gen_active = event_gen_active .and. (logical(scorep_is_measurement_phase(SCOREP_MEASUREMENT_PHASE_WITHIN_C)))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Initialized( &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Is_thread_main in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IS_THREAD_MAIN) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ENV)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IS_THREAD_MAIN ) && HAVE_F08_TS_BUFFERS_MPI_IS_THREAD_MAIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IS_THREAD_MAIN( &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Is_thread_main

    implicit none

! Dummy argument declarations
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IS_THREAD_MAIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Is_thread_main( &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Query_thread in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_QUERY_THREAD) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ENV)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_QUERY_THREAD ) && HAVE_F08_TS_BUFFERS_MPI_QUERY_THREAD )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_QUERY_THREAD( &
    provided, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Query_thread

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(OUT) :: provided
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_QUERY_THREAD)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Query_thread( &
        provided, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_call_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_CALL_ERRHANDLER) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_CALL_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_CALL_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_CALL_ERRHANDLER( &
    session, &
    errorcode, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_SESSION, &
        PMPI_Session_call_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    INTEGER, INTENT(IN) :: errorcode
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_CALL_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_call_errhandler( &
        session, &
        errorcode, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_create_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_CREATE_ERRHANDLER) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_CREATE_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_CREATE_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_CREATE_ERRHANDLER( &
    session_errhandler_fn, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_SESSION_ERRHANDLER_FUNCTION, &
        PMPI_Session_create_errhandler

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_SESSION_ERRHANDLER_FUNCTION) :: session_errhandler_fn
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_CREATE_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_create_errhandler( &
        session_errhandler_fn, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_finalize in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_FINALIZE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_FINALIZE ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_FINALIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_FINALIZE( &
    session, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_SESSION, &
        PMPI_Session_finalize

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(INOUT) :: session
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_FINALIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_finalize( &
        session, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_get_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_ERRHANDLER) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_ERRHANDLER( &
    session, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_SESSION, &
        PMPI_Session_get_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_GET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_get_errhandler( &
        session, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_get_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_INFO) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_INFO( &
    session, &
    info_used, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_SESSION, &
        PMPI_Session_get_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    TYPE(MPI_INFO), INTENT(OUT) :: info_used
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_GET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_get_info( &
        session, &
        info_used, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_get_nth_pset in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_NTH_PSET) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_NTH_PSET ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_NTH_PSET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_NTH_PSET( &
    session, &
    info, &
    n, &
    pset_len, &
    pset_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_SESSION, &
        PMPI_Session_get_nth_pset

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(IN) :: n
    INTEGER, INTENT(INOUT) :: pset_len
    CHARACTER(LEN=*), INTENT(OUT) :: pset_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_GET_NTH_PSET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_get_nth_pset( &
        session, &
        info, &
        n, &
        pset_len, &
        pset_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_get_num_psets in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_NUM_PSETS) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_NUM_PSETS ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_NUM_PSETS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_NUM_PSETS( &
    session, &
    info, &
    npset_names, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_SESSION, &
        PMPI_Session_get_num_psets

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(OUT) :: npset_names
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_GET_NUM_PSETS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_get_num_psets( &
        session, &
        info, &
        npset_names, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_get_pset_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_PSET_INFO) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_PSET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_GET_PSET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_GET_PSET_INFO( &
    session, &
    pset_name, &
    info, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_SESSION, &
        PMPI_Session_get_pset_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    CHARACTER(LEN=*), INTENT(IN) :: pset_name
    TYPE(MPI_INFO), INTENT(OUT) :: info
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_GET_PSET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_get_pset_info( &
        session, &
        pset_name, &
        info, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Aborts the measurement.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_INIT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_INIT ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_INIT( &
    info, &
    errhandler, &
    session, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_INFO, &
        MPI_SESSION, &
        PMPI_Session_init

    implicit none

! Dummy argument declarations
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    TYPE(MPI_SESSION), INTENT(OUT) :: session
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    print *, "[Score-P] Fatal: ", &
        "The MPI Sessions model is currently not supported by Score-P"
    ERROR STOP
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_init( &
        info, &
        errhandler, &
        session, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Session_set_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup env
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SESSION_SET_ERRHANDLER) && !defined(SCOREP_MPI_NO_ENV) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SESSION_SET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_SESSION_SET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SESSION_SET_ERRHANDLER( &
    session, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_SESSION, &
        PMPI_Session_set_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_SESSION), INTENT(IN) :: session
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SESSION_SET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_ENV) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Session_set_errhandler( &
        session, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
