!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_P2p.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for point-to-point communication
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Bsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BSEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BSEND ) && HAVE_F08_TS_BUFFERS_MPI_BSEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BSEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Bsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BSEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BSEND_C ) && HAVE_F08_TS_BUFFERS_MPI_BSEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BSEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Bsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bsend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BSEND_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BSEND_INIT ) && HAVE_F08_TS_BUFFERS_MPI_BSEND_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BSEND_INIT( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Bsend_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bsend_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Bsend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BSEND_INIT_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BSEND_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_BSEND_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BSEND_INIT_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Bsend_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Bsend_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Buffer_attach in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_ATTACH) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BUFFER_ATTACH ) && HAVE_F08_TS_BUFFERS_MPI_BUFFER_ATTACH )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_ATTACH( &
    buffer, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Buffer_attach

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buffer
    INTEGER, INTENT(IN) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BUFFER_ATTACH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Buffer_attach( &
        buffer, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Buffer_attach in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_ATTACH_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BUFFER_ATTACH_C ) && HAVE_F08_TS_BUFFERS_MPI_BUFFER_ATTACH_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_ATTACH_C( &
    buffer, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        PMPI_Buffer_attach

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buffer
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BUFFER_ATTACH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Buffer_attach( &
        buffer, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Buffer_detach in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_DETACH) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BUFFER_DETACH ) && HAVE_F08_TS_BUFFERS_MPI_BUFFER_DETACH )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_DETACH( &
    buffer_addr, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Buffer_detach

    implicit none

! Dummy argument declarations
    TYPE(C_PTR), INTENT(OUT) :: buffer_addr
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BUFFER_DETACH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Buffer_detach( &
        buffer_addr, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Buffer_detach in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_DETACH_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_BUFFER_DETACH_C ) && HAVE_F08_TS_BUFFERS_MPI_BUFFER_DETACH_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_BUFFER_DETACH_C( &
    buffer_addr, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        PMPI_Buffer_detach

    implicit none

! Dummy argument declarations
    TYPE(C_PTR), INTENT(OUT) :: buffer_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_BUFFER_DETACH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Buffer_detach( &
        buffer_addr, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ibsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IBSEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IBSEND ) && HAVE_F08_TS_BUFFERS_MPI_IBSEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IBSEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ibsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IBSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ibsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ibsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IBSEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IBSEND_C ) && HAVE_F08_TS_BUFFERS_MPI_IBSEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IBSEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ibsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IBSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ibsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Improbe in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IMPROBE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IMPROBE ) && HAVE_F08_TS_BUFFERS_MPI_IMPROBE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IMPROBE( &
    source, &
    tag, &
    comm, &
    flag, &
    message, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_MESSAGE, &
        MPI_STATUS, &
        PMPI_Improbe

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    LOGICAL, INTENT(OUT) :: flag
    TYPE(MPI_MESSAGE), INTENT(OUT) :: message
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IMPROBE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Improbe( &
        source, &
        tag, &
        comm, &
        flag, &
        message, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Imrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IMRECV) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IMRECV ) && HAVE_F08_TS_BUFFERS_MPI_IMRECV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IMRECV( &
    buf, &
    count, &
    datatype, &
    message, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_MESSAGE, &
        MPI_REQUEST, &
        PMPI_Imrecv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_MESSAGE), INTENT(INOUT) :: message
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IMRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Imrecv( &
        buf, &
        count, &
        datatype, &
        message, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Imrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IMRECV_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IMRECV_C ) && HAVE_F08_TS_BUFFERS_MPI_IMRECV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IMRECV_C( &
    buf, &
    count, &
    datatype, &
    message, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_MESSAGE, &
        MPI_REQUEST, &
        PMPI_Imrecv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_MESSAGE), INTENT(INOUT) :: message
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IMRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Imrecv( &
        buf, &
        count, &
        datatype, &
        message, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Iprobe in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IPROBE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IPROBE ) && HAVE_F08_TS_BUFFERS_MPI_IPROBE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IPROBE( &
    source, &
    tag, &
    comm, &
    flag, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_STATUS, &
        PMPI_Iprobe

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    LOGICAL, INTENT(OUT) :: flag
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IPROBE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Iprobe( &
        source, &
        tag, &
        comm, &
        flag, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Irecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IRECV) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IRECV ) && HAVE_F08_TS_BUFFERS_MPI_IRECV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IRECV( &
    buf, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Irecv, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Irecv( &
        buf, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                local_recv_bytes = count * local_recv_type_size
            end if

            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                local_comm_handle = scorep_mpi_comm_handle(comm)
                call SCOREP_MpiIrecvRequest(local_request_id)
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_RECV, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   0, &
                                                   local_recv_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Irecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IRECV_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IRECV_C ) && HAVE_F08_TS_BUFFERS_MPI_IRECV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IRECV_C( &
    buf, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Irecv, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Irecv( &
        buf, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                local_recv_bytes = count * local_recv_type_size
            end if

            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                local_comm_handle = scorep_mpi_comm_handle(comm)
                call SCOREP_MpiIrecvRequest(local_request_id)
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_RECV, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   0, &
                                                   local_recv_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Irsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IRSEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IRSEND ) && HAVE_F08_TS_BUFFERS_MPI_IRSEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IRSEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Irsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IRSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Irsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Irsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_IRSEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_IRSEND_C ) && HAVE_F08_TS_BUFFERS_MPI_IRSEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_IRSEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Irsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_IRSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Irsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Isend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISEND ) && HAVE_F08_TS_BUFFERS_MPI_ISEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Isend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Isend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Isend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISEND_C ) && HAVE_F08_TS_BUFFERS_MPI_ISEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Isend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Isend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Issend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISSEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISSEND ) && HAVE_F08_TS_BUFFERS_MPI_ISSEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISSEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Issend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Issend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Issend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISSEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISSEND_C ) && HAVE_F08_TS_BUFFERS_MPI_ISSEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISSEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Issend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiIsend(dest, local_comm_handle, tag, local_send_bytes, local_request_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Issend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Mprobe in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_MPROBE) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_MPROBE ) && HAVE_F08_TS_BUFFERS_MPI_MPROBE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_MPROBE( &
    source, &
    tag, &
    comm, &
    message, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_MESSAGE, &
        MPI_STATUS, &
        PMPI_Mprobe

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_MESSAGE), INTENT(OUT) :: message
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_MPROBE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Mprobe( &
        source, &
        tag, &
        comm, &
        message, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Mrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_MRECV) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_MRECV ) && HAVE_F08_TS_BUFFERS_MPI_MRECV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_MRECV( &
    buf, &
    count, &
    datatype, &
    message, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_MESSAGE, &
        MPI_STATUS, &
        PMPI_Mrecv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_MESSAGE), INTENT(INOUT) :: message
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_MRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Mrecv( &
        buf, &
        count, &
        datatype, &
        message, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Mrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_MRECV_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_MRECV_C ) && HAVE_F08_TS_BUFFERS_MPI_MRECV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_MRECV_C( &
    buf, &
    count, &
    datatype, &
    message, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_MESSAGE, &
        MPI_STATUS, &
        PMPI_Mrecv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_MESSAGE), INTENT(INOUT) :: message
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_MRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Mrecv( &
        buf, &
        count, &
        datatype, &
        message, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Probe in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PROBE) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PROBE ) && HAVE_F08_TS_BUFFERS_MPI_PROBE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PROBE( &
    source, &
    tag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_STATUS, &
        PMPI_Probe

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PROBE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Probe( &
        source, &
        tag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Recv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RECV) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RECV ) && HAVE_F08_TS_BUFFERS_MPI_RECV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RECV( &
    buf, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_SOURCE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        MPI_TAG, &
        PMPI_Get_count, &
        PMPI_Recv, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer :: local_recv_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Recv( &
        buf, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                call pmpi_get_count(internal_status, datatype, local_recv_count)
                local_recv_bytes = local_recv_count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call SCOREP_MpiRecv(internal_status%MPI_SOURCE, local_comm_handle, internal_status%MPI_TAG, local_recv_bytes)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Recv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RECV_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RECV_C ) && HAVE_F08_TS_BUFFERS_MPI_RECV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RECV_C( &
    buf, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_SOURCE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        MPI_TAG, &
        PMPI_Get_count, &
        PMPI_Recv, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer :: local_recv_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Recv( &
        buf, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                call pmpi_get_count(internal_status, datatype, local_recv_count)
                local_recv_bytes = local_recv_count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call SCOREP_MpiRecv(internal_status%MPI_SOURCE, local_comm_handle, internal_status%MPI_TAG, local_recv_bytes)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Recv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RECV_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RECV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_RECV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RECV_INIT( &
    buf, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Recv_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RECV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Recv_init( &
        buf, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                local_recv_bytes = count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create( &
                    request, &
                    SCOREP_MPI_REQUEST_TYPE_RECV, &
                    SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                    tag, &
                    source, &
                    local_recv_bytes, &
                    datatype, &
                    comm, &
                    local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Recv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RECV_INIT_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RECV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_RECV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RECV_INIT_C( &
    buf, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Recv_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RECV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Recv_init( &
        buf, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                local_recv_bytes = count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create( &
                    request, &
                    SCOREP_MPI_REQUEST_TYPE_RECV, &
                    SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                    tag, &
                    source, &
                    local_recv_bytes, &
                    datatype, &
                    comm, &
                    local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RSEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RSEND ) && HAVE_F08_TS_BUFFERS_MPI_RSEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RSEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Rsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rsend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RSEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RSEND_C ) && HAVE_F08_TS_BUFFERS_MPI_RSEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RSEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Rsend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rsend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rsend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RSEND_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RSEND_INIT ) && HAVE_F08_TS_BUFFERS_MPI_RSEND_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RSEND_INIT( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Rsend_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rsend_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rsend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RSEND_INIT_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RSEND_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_RSEND_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RSEND_INIT_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Rsend_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rsend_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Send in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SEND ) && HAVE_F08_TS_BUFFERS_MPI_SEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Send, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Send( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Send in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SEND_C ) && HAVE_F08_TS_BUFFERS_MPI_SEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Send, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Send( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Send_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SEND_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SEND_INIT ) && HAVE_F08_TS_BUFFERS_MPI_SEND_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SEND_INIT( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Send_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Send_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Send_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SEND_INIT_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SEND_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_SEND_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SEND_INIT_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Send_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Send_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Sendrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SENDRECV ) && HAVE_F08_TS_BUFFERS_MPI_SENDRECV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    dest, &
    sendtag, &
    recvbuf, &
    recvcount, &
    recvtype, &
    source, &
    recvtag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_SOURCE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        MPI_TAG, &
        PMPI_Get_count, &
        PMPI_Sendrecv, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer :: local_recv_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SENDRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(sendtype, local_send_type_size)
                local_send_bytes = sendcount * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, sendtag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Sendrecv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        dest, &
        sendtag, &
        recvbuf, &
        recvcount, &
        recvtype, &
        source, &
        recvtag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(recvtype, local_recv_type_size)
                call pmpi_get_count(internal_status, recvtype, local_recv_count)
                local_recv_bytes = local_recv_count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call SCOREP_MpiRecv(internal_status%MPI_SOURCE, local_comm_handle, internal_status%MPI_TAG, local_recv_bytes)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Sendrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SENDRECV_C ) && HAVE_F08_TS_BUFFERS_MPI_SENDRECV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    dest, &
    sendtag, &
    recvbuf, &
    recvcount, &
    recvtype, &
    source, &
    recvtag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_SOURCE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        MPI_TAG, &
        PMPI_Get_count, &
        PMPI_Sendrecv, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer :: local_recv_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SENDRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(sendtype, local_send_type_size)
                local_send_bytes = sendcount * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, sendtag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Sendrecv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        dest, &
        sendtag, &
        recvbuf, &
        recvcount, &
        recvtype, &
        source, &
        recvtag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(recvtype, local_recv_type_size)
                call pmpi_get_count(internal_status, recvtype, local_recv_count)
                local_recv_bytes = local_recv_count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call SCOREP_MpiRecv(internal_status%MPI_SOURCE, local_comm_handle, internal_status%MPI_TAG, local_recv_bytes)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Sendrecv_replace in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV_REPLACE) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SENDRECV_REPLACE ) && HAVE_F08_TS_BUFFERS_MPI_SENDRECV_REPLACE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV_REPLACE( &
    buf, &
    count, &
    datatype, &
    dest, &
    sendtag, &
    source, &
    recvtag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_SOURCE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        MPI_TAG, &
        PMPI_Get_count, &
        PMPI_Sendrecv_replace, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer :: local_recv_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SENDRECV_REPLACE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, sendtag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Sendrecv_replace( &
        buf, &
        count, &
        datatype, &
        dest, &
        sendtag, &
        source, &
        recvtag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                call pmpi_get_count(internal_status, datatype, local_recv_count)
                local_recv_bytes = local_recv_count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call SCOREP_MpiRecv(internal_status%MPI_SOURCE, local_comm_handle, internal_status%MPI_TAG, local_recv_bytes)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Sendrecv_replace in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV_REPLACE_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SENDRECV_REPLACE_C ) && HAVE_F08_TS_BUFFERS_MPI_SENDRECV_REPLACE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SENDRECV_REPLACE_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    sendtag, &
    source, &
    recvtag, &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_SOURCE, &
        MPI_STATUS, &
        MPI_SUCCESS, &
        MPI_TAG, &
        PMPI_Get_count, &
        PMPI_Sendrecv_replace, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_STATUS), TARGET :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    TYPE(MPI_STATUS), POINTER :: internal_status
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size
    integer(c_int64_t) :: local_recv_bytes
    integer :: local_recv_type_size
    integer :: local_recv_count

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SENDRECV_REPLACE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (scorep_mpi_is_status_ignore(status)) then
        call c_f_pointer(scorep_mpi_get_status_array(1_c_size_t), internal_status)
    else
        internal_status => status
    end if
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, sendtag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Sendrecv_replace( &
        buf, &
        count, &
        datatype, &
        dest, &
        sendtag, &
        source, &
        recvtag, &
        comm, &
        internal_status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call pmpi_type_size(datatype, local_recv_type_size)
                call pmpi_get_count(internal_status, datatype, local_recv_count)
                local_recv_bytes = local_recv_count * local_recv_type_size
            end if
            if (source .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call SCOREP_MpiRecv(internal_status%MPI_SOURCE, local_comm_handle, internal_status%MPI_TAG, local_recv_bytes)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ssend in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SSEND) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SSEND ) && HAVE_F08_TS_BUFFERS_MPI_SSEND )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SSEND( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Ssend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ssend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ssend in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SSEND_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SSEND_C ) && HAVE_F08_TS_BUFFERS_MPI_SSEND_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SSEND_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        PMPI_Ssend, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SSEND)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
            if (dest .ne. MPI_PROC_NULL) then
                call SCOREP_MpiSend(dest, local_comm_handle, tag, local_send_bytes)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ssend( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ssend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SSEND_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SSEND_INIT ) && HAVE_F08_TS_BUFFERS_MPI_SSEND_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SSEND_INIT( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ssend_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ssend_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ssend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SSEND_INIT_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SSEND_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_SSEND_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SSEND_INIT_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ssend_init, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_MpiRequestId) :: local_request_id
    integer(c_int64_t) :: local_send_bytes
    integer :: local_send_type_size

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_request_id = scorep_mpi_get_request_id()
            if (dest .ne. MPI_PROC_NULL) then
                call pmpi_type_size(datatype, local_send_type_size)
                local_send_bytes = count * local_send_type_size
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ssend_init( &
        buf, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (dest .ne. MPI_PROC_NULL .and. internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_p2p_create(request, &
                                                   SCOREP_MPI_REQUEST_TYPE_SEND, &
                                                   SCOREP_MPI_REQUEST_FLAG_IS_PERSISTENT, &
                                                   tag, &
                                                   dest, &
                                                   local_send_bytes, &
                                                   datatype, &
                                                   comm, &
                                                   local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Isendrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISENDRECV ) && HAVE_F08_TS_BUFFERS_MPI_ISENDRECV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    dest, &
    sendtag, &
    recvbuf, &
    recvcount, &
    recvtype, &
    source, &
    recvtag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        PMPI_Isendrecv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISENDRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Isendrecv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        dest, &
        sendtag, &
        recvbuf, &
        recvcount, &
        recvtype, &
        source, &
        recvtag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Isendrecv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISENDRECV_C ) && HAVE_F08_TS_BUFFERS_MPI_ISENDRECV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    dest, &
    sendtag, &
    recvbuf, &
    recvcount, &
    recvtype, &
    source, &
    recvtag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        PMPI_Isendrecv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISENDRECV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Isendrecv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        dest, &
        sendtag, &
        recvbuf, &
        recvcount, &
        recvtype, &
        source, &
        recvtag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Isendrecv_replace in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV_REPLACE) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISENDRECV_REPLACE ) && HAVE_F08_TS_BUFFERS_MPI_ISENDRECV_REPLACE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV_REPLACE( &
    buf, &
    count, &
    datatype, &
    dest, &
    sendtag, &
    source, &
    recvtag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        PMPI_Isendrecv_replace

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISENDRECV_REPLACE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Isendrecv_replace( &
        buf, &
        count, &
        datatype, &
        dest, &
        sendtag, &
        source, &
        recvtag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Isendrecv_replace in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV_REPLACE_C) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ISENDRECV_REPLACE_C ) && HAVE_F08_TS_BUFFERS_MPI_ISENDRECV_REPLACE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ISENDRECV_REPLACE_C( &
    buf, &
    count, &
    datatype, &
    dest, &
    sendtag, &
    source, &
    recvtag, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        PMPI_Isendrecv_replace

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: buf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: sendtag
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: recvtag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ISENDRECV_REPLACE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Isendrecv_replace( &
        buf, &
        count, &
        datatype, &
        dest, &
        sendtag, &
        source, &
        recvtag, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Precv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PRECV_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PRECV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_PRECV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PRECV_INIT( &
    buf, &
    partitions, &
    count, &
    datatype, &
    source, &
    tag, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Precv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: partitions
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: source
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PRECV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Precv_init( &
        buf, &
        partitions, &
        count, &
        datatype, &
        source, &
        tag, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Psend_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup p2p
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PSEND_INIT) && !defined(SCOREP_MPI_NO_P2P)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PSEND_INIT ) && HAVE_F08_TS_BUFFERS_MPI_PSEND_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PSEND_INIT( &
    buf, &
    partitions, &
    count, &
    datatype, &
    dest, &
    tag, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Psend_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: buf
    INTEGER, INTENT(IN) :: partitions
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: dest
    INTEGER, INTENT(IN) :: tag
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PSEND_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_P2P) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Psend_init( &
        buf, &
        partitions, &
        count, &
        datatype, &
        dest, &
        tag, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
