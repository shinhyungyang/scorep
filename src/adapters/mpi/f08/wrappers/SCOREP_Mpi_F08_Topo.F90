!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Topo.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for topologies
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Cart_coords in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_COORDS) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_COORDS ) && HAVE_F08_TS_BUFFERS_MPI_CART_COORDS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_COORDS( &
    comm, &
    rank, &
    maxdims, &
    coords, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Cart_coords

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: rank
    INTEGER, INTENT(IN) :: maxdims
    INTEGER, DIMENSION(MAXDIMS), INTENT(OUT) :: coords
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_COORDS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_coords( &
        comm, &
        rank, &
        maxdims, &
        coords, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cart_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_CREATE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_CART_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_CREATE( &
    comm_old, &
    ndims, &
    dims, &
    periods, &
    reorder, &
    comm_cart, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Cart_create

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm_old
    INTEGER, INTENT(IN) :: ndims
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: dims
    LOGICAL, DIMENSION(NDIMS), INTENT(IN) :: periods
    LOGICAL, INTENT(IN) :: reorder
    TYPE(MPI_COMM), INTENT(OUT) :: comm_cart
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm_old)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_create( &
        comm_old, &
        ndims, &
        dims, &
        periods, &
        reorder, &
        comm_cart, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (comm_cart .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(comm_cart, comm_old)
    end if
    if (comm_cart .ne. MPI_COMM_NULL .and. scorep_mpi_enable_topologies) then
        call scorep_mpi_topo_create_cart_definition("MPI_Cartesian", comm_cart)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cart_get in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_GET) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_GET ) && HAVE_F08_TS_BUFFERS_MPI_CART_GET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_GET( &
    comm, &
    maxdims, &
    dims, &
    periods, &
    coords, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Cart_get

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: maxdims
    INTEGER, DIMENSION(MAXDIMS), INTENT(OUT) :: dims
    LOGICAL, DIMENSION(MAXDIMS), INTENT(OUT) :: periods
    INTEGER, DIMENSION(MAXDIMS), INTENT(OUT) :: coords
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_GET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_get( &
        comm, &
        maxdims, &
        dims, &
        periods, &
        coords, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cart_map in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_MAP) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_MAP ) && HAVE_F08_TS_BUFFERS_MPI_CART_MAP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_MAP( &
    comm, &
    ndims, &
    dims, &
    periods, &
    newrank, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Cart_map

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: ndims
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: dims
    LOGICAL, DIMENSION(NDIMS), INTENT(IN) :: periods
    INTEGER, INTENT(OUT) :: newrank
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_MAP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_map( &
        comm, &
        ndims, &
        dims, &
        periods, &
        newrank, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cart_rank in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_RANK) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_RANK ) && HAVE_F08_TS_BUFFERS_MPI_CART_RANK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_RANK( &
    comm, &
    coords, &
    rank, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Cart_rank

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, DIMENSION(*), INTENT(IN) :: coords
    INTEGER, INTENT(OUT) :: rank
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_RANK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_rank( &
        comm, &
        coords, &
        rank, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cart_shift in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_SHIFT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_SHIFT ) && HAVE_F08_TS_BUFFERS_MPI_CART_SHIFT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_SHIFT( &
    comm, &
    direction, &
    disp, &
    rank_source, &
    rank_dest, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Cart_shift

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: direction
    INTEGER, INTENT(IN) :: disp
    INTEGER, INTENT(OUT) :: rank_source
    INTEGER, INTENT(OUT) :: rank_dest
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_SHIFT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_shift( &
        comm, &
        direction, &
        disp, &
        rank_source, &
        rank_dest, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cart_sub in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CART_SUB)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CART_SUB ) && HAVE_F08_TS_BUFFERS_MPI_CART_SUB )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CART_SUB( &
    comm, &
    remain_dims, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Cart_sub

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    LOGICAL, DIMENSION(*), INTENT(IN) :: remain_dims
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CART_SUB)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cart_sub( &
        comm, &
        remain_dims, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (newcomm .ne. MPI_COMM_NULL .and. scorep_mpi_enable_topologies) then
        call scorep_mpi_topo_create_cart_definition("Sub MPI_Cartesian", newcomm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Cartdim_get in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CARTDIM_GET) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CARTDIM_GET ) && HAVE_F08_TS_BUFFERS_MPI_CARTDIM_GET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CARTDIM_GET( &
    comm, &
    ndims, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Cartdim_get

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: ndims
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CARTDIM_GET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Cartdim_get( &
        comm, &
        ndims, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Dims_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_DIMS_CREATE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_DIMS_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_DIMS_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_DIMS_CREATE( &
    nnodes, &
    ndims, &
    dims, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Dims_create

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: nnodes
    INTEGER, INTENT(IN) :: ndims
    INTEGER, DIMENSION(NDIMS), INTENT(INOUT) :: dims
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_DIMS_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Dims_create( &
        nnodes, &
        ndims, &
        dims, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Dist_graph_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.2
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_CREATE) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_CREATE( &
    comm_old, &
    n, &
    sources, &
    degrees, &
    destinations, &
    weights, &
    info, &
    reorder, &
    comm_dist_graph, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Dist_graph_create

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm_old
    INTEGER, INTENT(IN) :: n
    INTEGER, DIMENSION(N), INTENT(IN) :: sources
    INTEGER, DIMENSION(N), INTENT(IN) :: degrees
    INTEGER, DIMENSION(*), INTENT(IN) :: destinations
    INTEGER, DIMENSION(*), INTENT(IN) :: weights
    TYPE(MPI_INFO), INTENT(IN) :: info
    LOGICAL, INTENT(IN) :: reorder
    TYPE(MPI_COMM), INTENT(OUT) :: comm_dist_graph
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_DIST_GRAPH_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm_old)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Dist_graph_create( &
        comm_old, &
        n, &
        sources, &
        degrees, &
        destinations, &
        weights, &
        info, &
        reorder, &
        comm_dist_graph, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (comm_dist_graph .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(comm_dist_graph, comm_old)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Dist_graph_create_adjacent in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.2
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_CREATE_ADJACENT) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_CREATE_ADJACENT ) && HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_CREATE_ADJACENT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_CREATE_ADJACENT( &
    comm_old, &
    indegree, &
    sources, &
    sourceweights, &
    outdegree, &
    destinations, &
    destweights, &
    info, &
    reorder, &
    comm_dist_graph, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Dist_graph_create_adjacent

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm_old
    INTEGER, INTENT(IN) :: indegree
    INTEGER, DIMENSION(INDEGREE), INTENT(IN) :: sources
    INTEGER, DIMENSION(*), INTENT(IN) :: sourceweights
    INTEGER, INTENT(IN) :: outdegree
    INTEGER, DIMENSION(OUTDEGREE), INTENT(IN) :: destinations
    INTEGER, DIMENSION(*), INTENT(IN) :: destweights
    TYPE(MPI_INFO), INTENT(IN) :: info
    LOGICAL, INTENT(IN) :: reorder
    TYPE(MPI_COMM), INTENT(OUT) :: comm_dist_graph
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_DIST_GRAPH_CREATE_ADJACENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm_old)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Dist_graph_create_adjacent( &
        comm_old, &
        indegree, &
        sources, &
        sourceweights, &
        outdegree, &
        destinations, &
        destweights, &
        info, &
        reorder, &
        comm_dist_graph, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (comm_dist_graph .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(comm_dist_graph, comm_old)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Dist_graph_neighbors in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.2
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_NEIGHBORS) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_NEIGHBORS ) && HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_NEIGHBORS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_NEIGHBORS( &
    comm, &
    maxindegree, &
    sources, &
    sourceweights, &
    maxoutdegree, &
    destinations, &
    destweights, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Dist_graph_neighbors

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: maxindegree
    INTEGER, DIMENSION(MAXINDEGREE), INTENT(OUT) :: sources
    INTEGER, DIMENSION(*) :: sourceweights
    INTEGER, INTENT(IN) :: maxoutdegree
    INTEGER, DIMENSION(MAXOUTDEGREE), INTENT(OUT) :: destinations
    INTEGER, DIMENSION(*) :: destweights
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_DIST_GRAPH_NEIGHBORS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Dist_graph_neighbors( &
        comm, &
        maxindegree, &
        sources, &
        sourceweights, &
        maxoutdegree, &
        destinations, &
        destweights, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Dist_graph_neighbors_count in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.2
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_NEIGHBORS_COUNT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_NEIGHBORS_COUNT ) && HAVE_F08_TS_BUFFERS_MPI_DIST_GRAPH_NEIGHBORS_COUNT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_DIST_GRAPH_NEIGHBORS_COUNT( &
    comm, &
    indegree, &
    outdegree, &
    weighted, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Dist_graph_neighbors_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: indegree
    INTEGER, INTENT(OUT) :: outdegree
    LOGICAL, INTENT(OUT) :: weighted
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_DIST_GRAPH_NEIGHBORS_COUNT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Dist_graph_neighbors_count( &
        comm, &
        indegree, &
        outdegree, &
        weighted, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Graph_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_CREATE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GRAPH_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_GRAPH_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_CREATE( &
    comm_old, &
    nnodes, &
    index, &
    edges, &
    reorder, &
    comm_graph, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Graph_create

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm_old
    INTEGER, INTENT(IN) :: nnodes
    INTEGER, DIMENSION(NNODES), INTENT(IN) :: index
    INTEGER, DIMENSION(*), INTENT(IN) :: edges
    LOGICAL, INTENT(IN) :: reorder
    TYPE(MPI_COMM), INTENT(OUT) :: comm_graph
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GRAPH_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm_old)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Graph_create( &
        comm_old, &
        nnodes, &
        index, &
        edges, &
        reorder, &
        comm_graph, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (comm_graph .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(comm_graph, comm_old)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Graph_get in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_GET) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GRAPH_GET ) && HAVE_F08_TS_BUFFERS_MPI_GRAPH_GET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_GET( &
    comm, &
    maxindex, &
    maxedges, &
    index, &
    edges, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Graph_get

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: maxindex
    INTEGER, INTENT(IN) :: maxedges
    INTEGER, DIMENSION(MAXINDEX), INTENT(OUT) :: index
    INTEGER, DIMENSION(MAXEDGES), INTENT(OUT) :: edges
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GRAPH_GET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Graph_get( &
        comm, &
        maxindex, &
        maxedges, &
        index, &
        edges, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Graph_map in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_MAP) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GRAPH_MAP ) && HAVE_F08_TS_BUFFERS_MPI_GRAPH_MAP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_MAP( &
    comm, &
    nnodes, &
    index, &
    edges, &
    newrank, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Graph_map

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: nnodes
    INTEGER, DIMENSION(NNODES), INTENT(IN) :: index
    INTEGER, DIMENSION(*), INTENT(IN) :: edges
    INTEGER, INTENT(OUT) :: newrank
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GRAPH_MAP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Graph_map( &
        comm, &
        nnodes, &
        index, &
        edges, &
        newrank, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Graph_neighbors in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_NEIGHBORS) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GRAPH_NEIGHBORS ) && HAVE_F08_TS_BUFFERS_MPI_GRAPH_NEIGHBORS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_NEIGHBORS( &
    comm, &
    rank, &
    maxneighbors, &
    neighbors, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Graph_neighbors

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: rank
    INTEGER, INTENT(IN) :: maxneighbors
    INTEGER, DIMENSION(MAXNEIGHBORS), INTENT(OUT) :: neighbors
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GRAPH_NEIGHBORS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Graph_neighbors( &
        comm, &
        rank, &
        maxneighbors, &
        neighbors, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Graph_neighbors_count in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_NEIGHBORS_COUNT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GRAPH_NEIGHBORS_COUNT ) && HAVE_F08_TS_BUFFERS_MPI_GRAPH_NEIGHBORS_COUNT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GRAPH_NEIGHBORS_COUNT( &
    comm, &
    rank, &
    nneighbors, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Graph_neighbors_count

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(IN) :: rank
    INTEGER, INTENT(OUT) :: nneighbors
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GRAPH_NEIGHBORS_COUNT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Graph_neighbors_count( &
        comm, &
        rank, &
        nneighbors, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Graphdims_get in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GRAPHDIMS_GET) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GRAPHDIMS_GET ) && HAVE_F08_TS_BUFFERS_MPI_GRAPHDIMS_GET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GRAPHDIMS_GET( &
    comm, &
    nnodes, &
    nedges, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Graphdims_get

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: nnodes
    INTEGER, INTENT(OUT) :: nedges
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GRAPHDIMS_GET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Graphdims_get( &
        comm, &
        nnodes, &
        nedges, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_allgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHER)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHER ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_allgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgather(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_r&
            &ecv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_allgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_allgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHER_C)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_allgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgather(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_r&
            &ecv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_allgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHER, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_allgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHERV) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHERV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_allgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgatherv(sendcount, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_allgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHERV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_allgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHERV_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLGATHERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLGATHERV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_allgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgatherv(sendcount, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_allgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLGATHERV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_alltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALL) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALL ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALL( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_alltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoall(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_re&
            &cv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_alltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALL, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_alltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALL_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALL_C ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALL_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_alltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoall(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_re&
            &cv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_alltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALL, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_alltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLV) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLV ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLV( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_alltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallv(sendcounts, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_alltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_alltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLV_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLV_C ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLV_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_alltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallv(sendcounts, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_alltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLV, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_alltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLW) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLW ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLW )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLW( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_alltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, comm, local_send_bytes, loc&
            &al_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_alltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLW, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Ineighbor_alltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLW_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLW_C ) && HAVE_F08_TS_BUFFERS_MPI_INEIGHBOR_ALLTOALLW_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_INEIGHBOR_ALLTOALLW_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_REQUEST, &
        MPI_SUCCESS, &
        PMPI_Ineighbor_alltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place
    integer(SCOREP_MpiRequestId) :: local_request_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_INEIGHBOR_ALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, comm, local_send_bytes, loc&
            &al_recv_bytes)
            local_request_id = scorep_mpi_get_request_id()
            call SCOREP_MpiNonBlockingCollectiveRequest(local_request_id)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Ineighbor_alltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (internal_ierror .eq. MPI_SUCCESS) then
                call scorep_mpi_request_icoll_create(request, &
                                                     SCOREP_MPI_REQUEST_FLAG_NONE, &
                                                     SCOREP_COLLECTIVE_ALLTOALLW, &
                                                     SCOREP_INVALID_ROOT_RANK, &
                                                     local_send_bytes, &
                                                     local_recv_bytes, &
                                                     comm, &
                                                     local_request_id)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Neighbor_allgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgather(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_r&
            &ecv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgather in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER_C)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Neighbor_allgather

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgather(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_r&
            &ecv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgather( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHER, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgather_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER_INIT) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER_INIT ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_allgather_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgather_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgather_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER_INIT_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHER_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHER_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_allgather_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHER_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgather_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Neighbor_allgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgatherv(sendcount, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgatherv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Neighbor_allgatherv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHERV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_allgatherv(sendcount, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgatherv( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLGATHERV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgatherv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV_INIT) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_allgatherv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgatherv_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_allgatherv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV_INIT_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLGATHERV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLGATHERV_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    displs, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_allgatherv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: displs
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLGATHERV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_allgatherv_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        displs, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Neighbor_alltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoall(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_re&
            &cv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALL, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoall in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Neighbor_alltoall

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoall(sendcount, sendtype, recvcount, recvtype, comm, local_send_bytes, local_re&
            &cv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoall( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALL, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoall_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL_INIT) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL_INIT ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL_INIT( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_alltoall_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALL_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoall_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoall_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL_INIT_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALL_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALL_INIT_C( &
    sendbuf, &
    sendcount, &
    sendtype, &
    recvbuf, &
    recvcount, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_alltoall_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: sendcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: recvcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALL_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoall_init( &
        sendbuf, &
        sendcount, &
        sendtype, &
        recvbuf, &
        recvcount, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Neighbor_alltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallv(sendcounts, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallv in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Neighbor_alltoallv

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLV)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallv(sendcounts, sendtype, recvcounts, recvtype, comm, local_send_bytes, local&
            &_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallv( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLV, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV_INIT) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV_INIT ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV_INIT( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_alltoallv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallv_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallv_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV_INIT_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLV_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLV_INIT_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtype, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtype, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_alltoallv_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: sendtype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), INTENT(IN) :: recvtype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLV_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallv_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtype, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtype, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Neighbor_alltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: sendtypes
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, comm, local_send_bytes, loc&
            &al_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLW, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallw in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Neighbor_alltoallw

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: sendtypes
    CHOICE_BUFFER_TYPE :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN) :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN) :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN) :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_send_bytes
    integer(c_int64_t) :: local_recv_bytes
    logical(c_bool) :: local_in_place

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLW)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    local_send_bytes = 0_c_int64_t
    local_recv_bytes = 0_c_int64_t
    local_in_place = .false.
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_coll_bytes_neighbor_alltoallw(sendcounts, sendtypes, recvcounts, recvtypes, comm, local_send_bytes, loc&
            &al_recv_bytes)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallw( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_MpiCollectiveEnd(scorep_mpi_comm_handle(comm), &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_ALLTOALLW, &
                                         local_send_bytes, &
                                         local_recv_bytes)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallw_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW_INIT) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW_INIT ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW_INIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW_INIT( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_alltoallw_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER, DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLW_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallw_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Neighbor_alltoallw_init in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW_INIT_C) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW_INIT_C ) && HAVE_F08_TS_BUFFERS_MPI_NEIGHBOR_ALLTOALLW_INIT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_NEIGHBOR_ALLTOALLW_INIT_C( &
    sendbuf, &
    sendcounts, &
    sdispls, &
    sendtypes, &
    recvbuf, &
    recvcounts, &
    rdispls, &
    recvtypes, &
    comm, &
    info, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_INFO, &
        MPI_REQUEST, &
        PMPI_Neighbor_alltoallw_init

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: sendbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: sendtypes
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: recvbuf
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvcounts
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: rdispls
    TYPE(MPI_DATATYPE), DIMENSION(*), INTENT(IN), ASYNCHRONOUS :: recvtypes
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_NEIGHBOR_ALLTOALLW_INIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Neighbor_alltoallw_init( &
        sendbuf, &
        sendcounts, &
        sdispls, &
        sendtypes, &
        recvbuf, &
        recvcounts, &
        rdispls, &
        recvtypes, &
        comm, &
        info, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Topo_test in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup topo
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TOPO_TEST) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TOPO)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TOPO_TEST ) && HAVE_F08_TS_BUFFERS_MPI_TOPO_TEST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TOPO_TEST( &
    comm, &
    status, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Topo_test

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: status
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TOPO_TEST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TOPO) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Topo_test( &
        comm, &
        status, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
