!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Type.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for datatype functions
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Pack in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK ) && HAVE_F08_TS_BUFFERS_MPI_PACK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK( &
    inbuf, &
    incount, &
    datatype, &
    outbuf, &
    outsize, &
    position, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Pack

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER, INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER, INTENT(IN) :: outsize
    INTEGER, INTENT(INOUT) :: position
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack( &
        inbuf, &
        incount, &
        datatype, &
        outbuf, &
        outsize, &
        position, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_C) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_C ) && HAVE_F08_TS_BUFFERS_MPI_PACK_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_C( &
    inbuf, &
    incount, &
    datatype, &
    outbuf, &
    outsize, &
    position, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Pack

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: outsize
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(INOUT) :: position
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack( &
        inbuf, &
        incount, &
        datatype, &
        outbuf, &
        outsize, &
        position, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack_external in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL ) && HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL( &
    datarep, &
    inbuf, &
    incount, &
    datatype, &
    outbuf, &
    outsize, &
    position, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Pack_external

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER, INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: outsize
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(INOUT) :: position
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK_EXTERNAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack_external( &
        datarep, &
        inbuf, &
        incount, &
        datatype, &
        outbuf, &
        outsize, &
        position, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack_external in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL_C ) && HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL_C( &
    datarep, &
    inbuf, &
    incount, &
    datatype, &
    outbuf, &
    outsize, &
    position, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Pack_external

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: outsize
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(INOUT) :: position
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK_EXTERNAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack_external( &
        datarep, &
        inbuf, &
        incount, &
        datatype, &
        outbuf, &
        outsize, &
        position, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack_external_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL_SIZE( &
    datarep, &
    incount, &
    datatype, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Pack_external_size

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    INTEGER, INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK_EXTERNAL_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack_external_size( &
        datarep, &
        incount, &
        datatype, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack_external_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL_SIZE_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL_SIZE_C ) && HAVE_F08_TS_BUFFERS_MPI_PACK_EXTERNAL_SIZE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_EXTERNAL_SIZE_C( &
    datarep, &
    incount, &
    datatype, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Pack_external_size

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK_EXTERNAL_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack_external_size( &
        datarep, &
        incount, &
        datatype, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_PACK_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_SIZE( &
    incount, &
    datatype, &
    comm, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Pack_size

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack_size( &
        incount, &
        datatype, &
        comm, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Pack_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PACK_SIZE_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PACK_SIZE_C ) && HAVE_F08_TS_BUFFERS_MPI_PACK_SIZE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PACK_SIZE_C( &
    incount, &
    datatype, &
    comm, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Pack_size

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: incount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PACK_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Pack_size( &
        incount, &
        datatype, &
        comm, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Sizeof in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_SIZEOF) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_SIZEOF ) && HAVE_F08_TS_BUFFERS_MPI_SIZEOF )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_SIZEOF( &
    x, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Sizeof

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE :: x
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_SIZEOF)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Sizeof( &
        x, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_commit in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_COMMIT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_COMMIT ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_COMMIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_COMMIT( &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_commit

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(INOUT) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_COMMIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_commit( &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_contiguous in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CONTIGUOUS) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CONTIGUOUS ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CONTIGUOUS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CONTIGUOUS( &
    count, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_contiguous

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CONTIGUOUS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_contiguous( &
        count, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_contiguous in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CONTIGUOUS_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CONTIGUOUS_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CONTIGUOUS_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CONTIGUOUS_C( &
    count, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_contiguous

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CONTIGUOUS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_contiguous( &
        count, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_darray in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_DARRAY) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_DARRAY ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_DARRAY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_DARRAY( &
    size, &
    rank, &
    ndims, &
    array_of_gsizes, &
    array_of_distribs, &
    array_of_dargs, &
    array_of_psizes, &
    order, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_create_darray

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: size
    INTEGER, INTENT(IN) :: rank
    INTEGER, INTENT(IN) :: ndims
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_gsizes
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_distribs
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_dargs
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_psizes
    INTEGER, INTENT(IN) :: order
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_DARRAY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_darray( &
        size, &
        rank, &
        ndims, &
        array_of_gsizes, &
        array_of_distribs, &
        array_of_dargs, &
        array_of_psizes, &
        order, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_darray in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_DARRAY_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_DARRAY_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_DARRAY_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_DARRAY_C( &
    size, &
    rank, &
    ndims, &
    array_of_gsizes, &
    array_of_distribs, &
    array_of_dargs, &
    array_of_psizes, &
    order, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_darray

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: size
    INTEGER, INTENT(IN) :: rank
    INTEGER, INTENT(IN) :: ndims
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(NDIMS), INTENT(IN) :: array_of_gsizes
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_distribs
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_dargs
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_psizes
    INTEGER, INTENT(IN) :: order
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_DARRAY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_darray( &
        size, &
        rank, &
        ndims, &
        array_of_gsizes, &
        array_of_distribs, &
        array_of_dargs, &
        array_of_psizes, &
        order, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_f90_complex in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_F90_COMPLEX) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_F90_COMPLEX ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_F90_COMPLEX )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_F90_COMPLEX( &
    p, &
    r, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_create_f90_complex

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: p
    INTEGER, INTENT(IN) :: r
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_F90_COMPLEX)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_f90_complex( &
        p, &
        r, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_f90_integer in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_F90_INTEGER) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_F90_INTEGER ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_F90_INTEGER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_F90_INTEGER( &
    r, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_create_f90_integer

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: r
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_F90_INTEGER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_f90_integer( &
        r, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_f90_real in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_F90_REAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_F90_REAL ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_F90_REAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_F90_REAL( &
    p, &
    r, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_create_f90_real

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: p
    INTEGER, INTENT(IN) :: r
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_F90_REAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_f90_real( &
        p, &
        r, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_hindexed in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED( &
    count, &
    array_of_blocklengths, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_hindexed

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, DIMENSION(COUNT), INTENT(IN) :: array_of_blocklengths
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_HINDEXED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_hindexed( &
        count, &
        array_of_blocklengths, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_hindexed in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED_C( &
    count, &
    array_of_blocklengths, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_hindexed

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_blocklengths
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_HINDEXED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_hindexed( &
        count, &
        array_of_blocklengths, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_hindexed_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED_BLOCK) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED_BLOCK ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED_BLOCK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED_BLOCK( &
    count, &
    blocklength, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_hindexed_block

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, INTENT(IN) :: blocklength
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_HINDEXED_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_hindexed_block( &
        count, &
        blocklength, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_hindexed_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED_BLOCK_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED_BLOCK_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HINDEXED_BLOCK_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HINDEXED_BLOCK_C( &
    count, &
    blocklength, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_hindexed_block

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: blocklength
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_HINDEXED_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_hindexed_block( &
        count, &
        blocklength, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_hvector in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HVECTOR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HVECTOR ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HVECTOR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HVECTOR( &
    count, &
    blocklength, &
    stride, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_hvector

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, INTENT(IN) :: blocklength
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: stride
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_HVECTOR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_hvector( &
        count, &
        blocklength, &
        stride, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_hvector in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HVECTOR_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HVECTOR_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_HVECTOR_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_HVECTOR_C( &
    count, &
    blocklength, &
    stride, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_hvector

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: blocklength
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: stride
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_HVECTOR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_hvector( &
        count, &
        blocklength, &
        stride, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_indexed_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_INDEXED_BLOCK) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_INDEXED_BLOCK ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_INDEXED_BLOCK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_INDEXED_BLOCK( &
    count, &
    blocklength, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_create_indexed_block

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, INTENT(IN) :: blocklength
    INTEGER, DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_INDEXED_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_indexed_block( &
        count, &
        blocklength, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_indexed_block in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_INDEXED_BLOCK_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_INDEXED_BLOCK_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_INDEXED_BLOCK_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_INDEXED_BLOCK_C( &
    count, &
    blocklength, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_indexed_block

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: blocklength
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_INDEXED_BLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_indexed_block( &
        count, &
        blocklength, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_resized in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_RESIZED) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_RESIZED ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_RESIZED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_RESIZED( &
    oldtype, &
    lb, &
    extent, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_resized

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: lb
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: extent
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_RESIZED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_resized( &
        oldtype, &
        lb, &
        extent, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_resized in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_RESIZED_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_RESIZED_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_RESIZED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_RESIZED_C( &
    oldtype, &
    lb, &
    extent, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_resized

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: lb
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: extent
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_RESIZED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_resized( &
        oldtype, &
        lb, &
        extent, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_struct in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_STRUCT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_STRUCT ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_STRUCT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_STRUCT( &
    count, &
    array_of_blocklengths, &
    array_of_displacements, &
    array_of_types, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_struct

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, DIMENSION(COUNT), INTENT(IN) :: array_of_blocklengths
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), DIMENSION(COUNT), INTENT(IN) :: array_of_types
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_STRUCT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_struct( &
        count, &
        array_of_blocklengths, &
        array_of_displacements, &
        array_of_types, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_struct in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_STRUCT_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_STRUCT_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_STRUCT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_STRUCT_C( &
    count, &
    array_of_blocklengths, &
    array_of_displacements, &
    array_of_types, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_struct

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_blocklengths
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), DIMENSION(COUNT), INTENT(IN) :: array_of_types
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_STRUCT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_struct( &
        count, &
        array_of_blocklengths, &
        array_of_displacements, &
        array_of_types, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_subarray in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_SUBARRAY) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_SUBARRAY ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_SUBARRAY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_SUBARRAY( &
    ndims, &
    array_of_sizes, &
    array_of_subsizes, &
    array_of_starts, &
    order, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_create_subarray

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: ndims
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_sizes
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_subsizes
    INTEGER, DIMENSION(NDIMS), INTENT(IN) :: array_of_starts
    INTEGER, INTENT(IN) :: order
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_SUBARRAY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_subarray( &
        ndims, &
        array_of_sizes, &
        array_of_subsizes, &
        array_of_starts, &
        order, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_subarray in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_SUBARRAY_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_SUBARRAY_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_SUBARRAY_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_SUBARRAY_C( &
    ndims, &
    array_of_sizes, &
    array_of_subsizes, &
    array_of_starts, &
    order, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_create_subarray

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: ndims
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(NDIMS), INTENT(IN) :: array_of_sizes
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(NDIMS), INTENT(IN) :: array_of_subsizes
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(NDIMS), INTENT(IN) :: array_of_starts
    INTEGER, INTENT(IN) :: order
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_SUBARRAY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_subarray( &
        ndims, &
        array_of_sizes, &
        array_of_subsizes, &
        array_of_starts, &
        order, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_dup in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_DUP) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_DUP ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_DUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_DUP( &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_dup

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_DUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_dup( &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_free in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_FREE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_FREE ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_FREE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_FREE( &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(INOUT) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_FREE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_free( &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_contents in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_CONTENTS) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_CONTENTS ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_CONTENTS )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_CONTENTS( &
    datatype, &
    max_integers, &
    max_addresses, &
    max_datatypes, &
    array_of_integers, &
    array_of_addresses, &
    array_of_datatypes, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_contents

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: max_integers
    INTEGER, INTENT(IN) :: max_addresses
    INTEGER, INTENT(IN) :: max_datatypes
    INTEGER, DIMENSION(MAX_INTEGERS), INTENT(OUT) :: array_of_integers
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(MAX_ADDRESSES), INTENT(OUT) :: array_of_addresses
    TYPE(MPI_DATATYPE), DIMENSION(MAX_DATATYPES), INTENT(OUT) :: array_of_datatypes
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_CONTENTS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_contents( &
        datatype, &
        max_integers, &
        max_addresses, &
        max_datatypes, &
        array_of_integers, &
        array_of_addresses, &
        array_of_datatypes, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_contents in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_CONTENTS_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_CONTENTS_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_CONTENTS_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_CONTENTS_C( &
    datatype, &
    max_integers, &
    max_addresses, &
    max_large_counts, &
    max_datatypes, &
    array_of_integers, &
    array_of_addresses, &
    array_of_large_counts, &
    array_of_datatypes, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_contents

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: max_integers
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: max_addresses
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: max_large_counts
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: max_datatypes
    INTEGER, DIMENSION(MAX_INTEGERS), INTENT(OUT) :: array_of_integers
    INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(MAX_ADDRESSES), INTENT(OUT) :: array_of_addresses
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(MAX_LARGE_COUNTS), INTENT(OUT) :: array_of_large_counts
    TYPE(MPI_DATATYPE), DIMENSION(MAX_DATATYPES), INTENT(OUT) :: array_of_datatypes
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_CONTENTS)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_contents( &
        datatype, &
        max_integers, &
        max_addresses, &
        max_large_counts, &
        max_datatypes, &
        array_of_integers, &
        array_of_addresses, &
        array_of_large_counts, &
        array_of_datatypes, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_envelope in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_ENVELOPE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_ENVELOPE ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_ENVELOPE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_ENVELOPE( &
    datatype, &
    num_integers, &
    num_addresses, &
    num_datatypes, &
    combiner, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_get_envelope

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT) :: num_integers
    INTEGER, INTENT(OUT) :: num_addresses
    INTEGER, INTENT(OUT) :: num_datatypes
    INTEGER, INTENT(OUT) :: combiner
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_ENVELOPE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_envelope( &
        datatype, &
        num_integers, &
        num_addresses, &
        num_datatypes, &
        combiner, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_envelope in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_ENVELOPE_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_ENVELOPE_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_ENVELOPE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_ENVELOPE_C( &
    datatype, &
    num_integers, &
    num_addresses, &
    num_large_counts, &
    num_datatypes, &
    combiner, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_envelope

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: num_integers
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: num_addresses
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: num_large_counts
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: num_datatypes
    INTEGER, INTENT(OUT) :: combiner
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_ENVELOPE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_envelope( &
        datatype, &
        num_integers, &
        num_addresses, &
        num_large_counts, &
        num_datatypes, &
        combiner, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_extent in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_EXTENT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_EXTENT ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_EXTENT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_EXTENT( &
    datatype, &
    lb, &
    extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_extent

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: lb
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_EXTENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_extent( &
        datatype, &
        lb, &
        extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_extent in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_EXTENT_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_EXTENT_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_EXTENT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_EXTENT_C( &
    datatype, &
    lb, &
    extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_extent

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: lb
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_EXTENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_extent( &
        datatype, &
        lb, &
        extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_extent_x in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_EXTENT_X) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_EXTENT_X ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_EXTENT_X )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_EXTENT_X( &
    datatype, &
    lb, &
    extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_extent_x

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: lb
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_EXTENT_X)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_extent_x( &
        datatype, &
        lb, &
        extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_true_extent in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_TRUE_EXTENT) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_TRUE_EXTENT ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_TRUE_EXTENT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_TRUE_EXTENT( &
    datatype, &
    true_lb, &
    true_extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_true_extent

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: true_lb
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: true_extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_TRUE_EXTENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_true_extent( &
        datatype, &
        true_lb, &
        true_extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_true_extent in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_TRUE_EXTENT_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_TRUE_EXTENT_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_TRUE_EXTENT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_TRUE_EXTENT_C( &
    datatype, &
    true_lb, &
    true_extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_true_extent

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: true_lb
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: true_extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_TRUE_EXTENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_true_extent( &
        datatype, &
        true_lb, &
        true_extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_true_extent_x in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_TRUE_EXTENT_X) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_TRUE_EXTENT_X ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_TRUE_EXTENT_X )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_TRUE_EXTENT_X( &
    datatype, &
    true_lb, &
    true_extent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_true_extent_x

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: true_lb
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: true_extent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_TRUE_EXTENT_X)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_true_extent_x( &
        datatype, &
        true_lb, &
        true_extent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_indexed in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_INDEXED) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_INDEXED ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_INDEXED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_INDEXED( &
    count, &
    array_of_blocklengths, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_indexed

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, DIMENSION(COUNT), INTENT(IN) :: array_of_blocklengths
    INTEGER, DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_INDEXED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_indexed( &
        count, &
        array_of_blocklengths, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_indexed in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_INDEXED_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_INDEXED_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_INDEXED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_INDEXED_C( &
    count, &
    array_of_blocklengths, &
    array_of_displacements, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_indexed

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_blocklengths
    INTEGER(KIND=MPI_COUNT_KIND), DIMENSION(COUNT), INTENT(IN) :: array_of_displacements
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_INDEXED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_indexed( &
        count, &
        array_of_blocklengths, &
        array_of_displacements, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_match_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_MATCH_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_MATCH_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_MATCH_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_MATCH_SIZE( &
    typeclass, &
    size, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_match_size

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: typeclass
    INTEGER, INTENT(IN) :: size
    TYPE(MPI_DATATYPE), INTENT(OUT) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_MATCH_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_match_size( &
        typeclass, &
        size, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SIZE) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_SIZE ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_SIZE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SIZE( &
    datatype, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_size( &
        datatype, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_size in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SIZE_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_SIZE_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_SIZE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SIZE_C( &
    datatype, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_size

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_SIZE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_size( &
        datatype, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_size_x in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SIZE_X) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_SIZE_X ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_SIZE_X )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SIZE_X( &
    datatype, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_size_x

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_SIZE_X)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_size_x( &
        datatype, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_vector in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_VECTOR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_VECTOR ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_VECTOR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_VECTOR( &
    count, &
    blocklength, &
    stride, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_vector

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    INTEGER, INTENT(IN) :: blocklength
    INTEGER, INTENT(IN) :: stride
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_VECTOR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_vector( &
        count, &
        blocklength, &
        stride, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_vector in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_VECTOR_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_VECTOR_C ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_VECTOR_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_VECTOR_C( &
    count, &
    blocklength, &
    stride, &
    oldtype, &
    newtype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_vector

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: count
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: blocklength
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: stride
    TYPE(MPI_DATATYPE), INTENT(IN) :: oldtype
    TYPE(MPI_DATATYPE), INTENT(OUT) :: newtype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_VECTOR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_vector( &
        count, &
        blocklength, &
        stride, &
        oldtype, &
        newtype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Unpack in the Fortran 2008 bindings.
!> @note Introduced in MPI 1.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_UNPACK) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_UNPACK ) && HAVE_F08_TS_BUFFERS_MPI_UNPACK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_UNPACK( &
    inbuf, &
    insize, &
    position, &
    outbuf, &
    outcount, &
    datatype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_DATATYPE, &
        PMPI_Unpack

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER, INTENT(IN) :: insize
    INTEGER, INTENT(INOUT) :: position
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER, INTENT(IN) :: outcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_UNPACK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Unpack( &
        inbuf, &
        insize, &
        position, &
        outbuf, &
        outcount, &
        datatype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Unpack in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_UNPACK_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_UNPACK_C ) && HAVE_F08_TS_BUFFERS_MPI_UNPACK_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_UNPACK_C( &
    inbuf, &
    insize, &
    position, &
    outbuf, &
    outcount, &
    datatype, &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Unpack

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: insize
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(INOUT) :: position
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: outcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    TYPE(MPI_COMM), INTENT(IN) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_UNPACK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Unpack( &
        inbuf, &
        insize, &
        position, &
        outbuf, &
        outcount, &
        datatype, &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Unpack_external in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_UNPACK_EXTERNAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_UNPACK_EXTERNAL ) && HAVE_F08_TS_BUFFERS_MPI_UNPACK_EXTERNAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_UNPACK_EXTERNAL( &
    datarep, &
    inbuf, &
    insize, &
    position, &
    outbuf, &
    outcount, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Unpack_external

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: insize
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(INOUT) :: position
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER, INTENT(IN) :: outcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_UNPACK_EXTERNAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Unpack_external( &
        datarep, &
        inbuf, &
        insize, &
        position, &
        outbuf, &
        outcount, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Unpack_external in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup type
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_UNPACK_EXTERNAL_C) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_UNPACK_EXTERNAL_C ) && HAVE_F08_TS_BUFFERS_MPI_UNPACK_EXTERNAL_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_UNPACK_EXTERNAL_C( &
    datarep, &
    inbuf, &
    insize, &
    position, &
    outbuf, &
    outcount, &
    datatype, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        PMPI_Unpack_external

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: datarep
    CHOICE_BUFFER_TYPE, INTENT(IN) :: inbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: insize
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(INOUT) :: position
    CHOICE_BUFFER_TYPE :: outbuf
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: outcount
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_UNPACK_EXTERNAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE) .g&
    &t. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Unpack_external( &
        datarep, &
        inbuf, &
        insize, &
        position, &
        outbuf, &
        outcount, &
        datatype, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_create_keyval in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_KEYVAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_KEYVAL ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_CREATE_KEYVAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_CREATE_KEYVAL( &
    type_copy_attr_fn, &
    type_delete_attr_fn, &
    type_keyval, &
    extra_state, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_TYPE_COPY_ATTR_FUNCTION, &
        MPI_TYPE_DELETE_ATTR_FUNCTION, &
        PMPI_Type_create_keyval

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_TYPE_COPY_ATTR_FUNCTION) :: type_copy_attr_fn
    PROCEDURE(MPI_TYPE_DELETE_ATTR_FUNCTION) :: type_delete_attr_fn
    INTEGER, INTENT(OUT) :: type_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: extra_state
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_CREATE_KEYVAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_create_keyval( &
        type_copy_attr_fn, &
        type_delete_attr_fn, &
        type_keyval, &
        extra_state, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_delete_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_DELETE_ATTR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_DELETE_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_DELETE_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_DELETE_ATTR( &
    datatype, &
    type_keyval, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_delete_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: type_keyval
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_DELETE_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_delete_attr( &
        datatype, &
        type_keyval, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_free_keyval in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_FREE_KEYVAL) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_FREE_KEYVAL ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_FREE_KEYVAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_FREE_KEYVAL( &
    type_keyval, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Type_free_keyval

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(INOUT) :: type_keyval
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_FREE_KEYVAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_free_keyval( &
        type_keyval, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_ATTR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_ATTR( &
    datatype, &
    type_keyval, &
    attribute_val, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_get_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: type_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: attribute_val
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_attr( &
        datatype, &
        type_keyval, &
        attribute_val, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_get_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_NAME) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_NAME ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_GET_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_GET_NAME( &
    datatype, &
    type_name, &
    resultlen, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        MPI_MAX_OBJECT_NAME, &
        PMPI_Type_get_name

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    CHARACTER(LEN=MPI_MAX_OBJECT_NAME), INTENT(OUT) :: type_name
    INTEGER, INTENT(OUT) :: resultlen
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_GET_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_get_name( &
        datatype, &
        type_name, &
        resultlen, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_set_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SET_ATTR) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_SET_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_SET_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SET_ATTR( &
    datatype, &
    type_keyval, &
    attribute_val, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        PMPI_Type_set_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: type_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: attribute_val
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_SET_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_set_attr( &
        datatype, &
        type_keyval, &
        attribute_val, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Type_set_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup type_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SET_NAME) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_TYPE) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_TYPE_SET_NAME ) && HAVE_F08_TS_BUFFERS_MPI_TYPE_SET_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_TYPE_SET_NAME( &
    datatype, &
    type_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_DATATYPE, &
        PMPI_Type_set_name

    implicit none

! Dummy argument declarations
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    CHARACTER(LEN=*), INTENT(IN) :: type_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_TYPE_SET_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_TYPE_EXT&
    &) .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Type_set_name( &
        datatype, &
        type_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
