!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Spawn.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for process creation and management functions (spawning interface)
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Close_port in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_CLOSE_PORT) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_CLOSE_PORT ) && HAVE_F08_TS_BUFFERS_MPI_CLOSE_PORT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_CLOSE_PORT( &
    port_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Close_port

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: port_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_CLOSE_PORT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Close_port( &
        port_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_accept in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_ACCEPT) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_ACCEPT ) && HAVE_F08_TS_BUFFERS_MPI_COMM_ACCEPT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_ACCEPT( &
    port_name, &
    info, &
    root, &
    comm, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Comm_accept

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: port_name
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_ACCEPT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_accept( &
        port_name, &
        info, &
        root, &
        comm, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_connect in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_CONNECT) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_CONNECT ) && HAVE_F08_TS_BUFFERS_MPI_COMM_CONNECT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_CONNECT( &
    port_name, &
    info, &
    root, &
    comm, &
    newcomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Comm_connect

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: port_name
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_COMM), INTENT(OUT) :: newcomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_CONNECT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_connect( &
        port_name, &
        info, &
        root, &
        comm, &
        newcomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (newcomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(newcomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_disconnect in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_DISCONNECT) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_DISCONNECT ) && HAVE_F08_TS_BUFFERS_MPI_COMM_DISCONNECT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_DISCONNECT( &
    comm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_disconnect

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(INOUT) :: comm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_DISCONNECT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_mpi_comm_free(comm)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_disconnect( &
        comm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_CommDestroy(local_comm_handle)
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_DESTROY_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_get_parent in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_PARENT) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_GET_PARENT ) && HAVE_F08_TS_BUFFERS_MPI_COMM_GET_PARENT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_GET_PARENT( &
    parent, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        PMPI_Comm_get_parent

    implicit none

! Dummy argument declarations
    TYPE(MPI_COMM), INTENT(OUT) :: parent
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_GET_PARENT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_get_parent( &
        parent, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_join in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_JOIN) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_JOIN ) && HAVE_F08_TS_BUFFERS_MPI_COMM_JOIN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_JOIN( &
    fd, &
    intercomm, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        PMPI_Comm_join

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: fd
    TYPE(MPI_COMM), INTENT(OUT) :: intercomm
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_JOIN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_join( &
        fd, &
        intercomm, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (intercomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(intercomm, MPI_COMM_NULL)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            else
                ! The communicator creation was a local operation, hence we use MPI_COMM_SELF for the collective
                local_new_comm_handle = scorep_mpi_comm_handle(MPI_COMM_SELF)
            end if
            call SCOREP_MpiCollectiveEnd(local_new_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_spawn in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPAWN) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SPAWN ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SPAWN )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPAWN( &
    command, &
    argv, &
    maxprocs, &
    info, &
    root, &
    comm, &
    intercomm, &
    array_of_errcodes, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Comm_spawn

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: command
    CHARACTER(LEN=*), DIMENSION(*), INTENT(IN) :: argv
    INTEGER, INTENT(IN) :: maxprocs
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_COMM), INTENT(OUT) :: intercomm
    INTEGER, DIMENSION(*) :: array_of_errcodes
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SPAWN)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_spawn( &
        command, &
        argv, &
        maxprocs, &
        info, &
        root, &
        comm, &
        intercomm, &
        array_of_errcodes, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (intercomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(intercomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Comm_spawn_multiple in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPAWN_MULTIPLE) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMM_SPAWN_MULTIPLE ) && HAVE_F08_TS_BUFFERS_MPI_COMM_SPAWN_MULTIPLE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMM_SPAWN_MULTIPLE( &
    count, &
    array_of_commands, &
    array_of_argv, &
    array_of_maxprocs, &
    array_of_info, &
    root, &
    comm, &
    intercomm, &
    array_of_errcodes, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_COMM_NULL, &
        MPI_COMM_SELF, &
        MPI_INFO, &
        PMPI_Comm_spawn_multiple

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: count
    CHARACTER(LEN=*), DIMENSION(*), INTENT(IN) :: array_of_commands
    CHARACTER(LEN=*), DIMENSION(COUNT, *), INTENT(IN) :: array_of_argv
    INTEGER, DIMENSION(*), INTENT(IN) :: array_of_maxprocs
    TYPE(MPI_INFO), DIMENSION(*), INTENT(IN) :: array_of_info
    INTEGER, INTENT(IN) :: root
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_COMM), INTENT(OUT) :: intercomm
    INTEGER, DIMENSION(*) :: array_of_errcodes
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_InterimCommunicatorHandle) :: local_comm_handle
    integer(SCOREP_InterimCommunicatorHandle) :: local_new_comm_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMM_SPAWN_MULTIPLE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    local_new_comm_handle = SCOREP_INVALID_INTERIM_COMMUNICATOR
    local_comm_handle = scorep_mpi_comm_handle(comm)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_MpiCollectiveBegin()
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Comm_spawn_multiple( &
        count, &
        array_of_commands, &
        array_of_argv, &
        array_of_maxprocs, &
        array_of_info, &
        root, &
        comm, &
        intercomm, &
        array_of_errcodes, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (intercomm .ne. MPI_COMM_NULL) then
        local_new_comm_handle = scorep_mpi_comm_create(intercomm, comm)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (local_new_comm_handle .ne. SCOREP_INVALID_INTERIM_COMMUNICATOR) then
                call SCOREP_CommCreate(local_new_comm_handle)
            end if
            call SCOREP_MpiCollectiveEnd(local_comm_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         0_c_int64_t, &
                                         0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Lookup_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_LOOKUP_NAME) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_LOOKUP_NAME ) && HAVE_F08_TS_BUFFERS_MPI_LOOKUP_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_LOOKUP_NAME( &
    service_name, &
    info, &
    port_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_MAX_PORT_NAME, &
        PMPI_Lookup_name

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: service_name
    TYPE(MPI_INFO), INTENT(IN) :: info
    CHARACTER(LEN=MPI_MAX_PORT_NAME), INTENT(OUT) :: port_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_LOOKUP_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Lookup_name( &
        service_name, &
        info, &
        port_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Open_port in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_OPEN_PORT) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_OPEN_PORT ) && HAVE_F08_TS_BUFFERS_MPI_OPEN_PORT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_OPEN_PORT( &
    info, &
    port_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_MAX_PORT_NAME, &
        PMPI_Open_port

    implicit none

! Dummy argument declarations
    TYPE(MPI_INFO), INTENT(IN) :: info
    CHARACTER(LEN=MPI_MAX_PORT_NAME), INTENT(OUT) :: port_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_OPEN_PORT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Open_port( &
        info, &
        port_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Publish_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PUBLISH_NAME) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PUBLISH_NAME ) && HAVE_F08_TS_BUFFERS_MPI_PUBLISH_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PUBLISH_NAME( &
    service_name, &
    info, &
    port_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        PMPI_Publish_name

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: service_name
    TYPE(MPI_INFO), INTENT(IN) :: info
    CHARACTER(LEN=*), INTENT(IN) :: port_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PUBLISH_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Publish_name( &
        service_name, &
        info, &
        port_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Unpublish_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup spawn
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_UNPUBLISH_NAME) && !defined(SCOREP_MPI_NO_SPAWN) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_UNPUBLISH_NAME ) && HAVE_F08_TS_BUFFERS_MPI_UNPUBLISH_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_UNPUBLISH_NAME( &
    service_name, &
    info, &
    port_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        PMPI_Unpublish_name

    implicit none

! Dummy argument declarations
    CHARACTER(LEN=*), INTENT(IN) :: service_name
    TYPE(MPI_INFO), INTENT(IN) :: info
    CHARACTER(LEN=*), INTENT(IN) :: port_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_UNPUBLISH_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_SPAWN) .&
    &gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Unpublish_name( &
        service_name, &
        info, &
        port_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
