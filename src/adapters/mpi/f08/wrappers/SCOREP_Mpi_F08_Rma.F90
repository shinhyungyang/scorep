!
! This file is part of the Score-P software (http://www.score-p.org)
!
! Copyright (c) 2025,
! Forschungszentrum Juelich GmbH, Germany
!
! This software may be modified and distributed under the terms of
! a BSD-style license. See the COPYING file in the package base
! directory for details.
!

!
! This file was generated by mpi_wrapgen2 from template adapter/f08/wrappers/SCOREP_Mpi_F08_Rma.F90.tmpl.
!

!>
!> @file
!> @ingroup    MPI_Wrapper
!>
!> @brief F08 wrappers for one-sided communication
!>

#include <config.h>

!>
!> @name F08 wrappers
!>
!> @{
!>

!>
!> Measurement wrapper for MPI_Accumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ACCUMULATE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ACCUMULATE ) && HAVE_F08_TS_BUFFERS_MPI_ACCUMULATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ACCUMULATE( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Accumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = 0
                local_bytes_put = origin_count * get_datatype_size(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Accumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Accumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_ACCUMULATE_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_ACCUMULATE_C ) && HAVE_F08_TS_BUFFERS_MPI_ACCUMULATE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_ACCUMULATE_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Accumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_ACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = 0
                local_bytes_put = origin_count * get_datatype_size_c(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Accumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Compare_and_swap in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_COMPARE_AND_SWAP) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_COMPARE_AND_SWAP ) && HAVE_F08_TS_BUFFERS_MPI_COMPARE_AND_SWAP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_COMPARE_AND_SWAP( &
    origin_addr, &
    compare_addr, &
    result_addr, &
    datatype, &
    target_rank, &
    target_disp, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Compare_and_swap

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: compare_addr
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: result_addr
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_COMPARE_AND_SWAP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = get_datatype_size(datatype)
                local_bytes_put = get_datatype_size(datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_COMPARE_AND_SWAP, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Compare_and_swap( &
        origin_addr, &
        compare_addr, &
        result_addr, &
        datatype, &
        target_rank, &
        target_disp, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Fetch_and_op in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_FETCH_AND_OP) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_FETCH_AND_OP ) && HAVE_F08_TS_BUFFERS_MPI_FETCH_AND_OP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_FETCH_AND_OP( &
    origin_addr, &
    result_addr, &
    datatype, &
    target_rank, &
    target_disp, &
    op, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Fetch_and_op

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: result_addr
    TYPE(MPI_DATATYPE), INTENT(IN) :: datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_FETCH_AND_OP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = get_datatype_size(datatype)
                local_bytes_put = get_datatype_size(datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_FETCH_AND_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Fetch_and_op( &
        origin_addr, &
        result_addr, &
        datatype, &
        target_rank, &
        target_disp, &
        op, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Get in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GET) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GET ) && HAVE_F08_TS_BUFFERS_MPI_GET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GET( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Get

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_COMBINED_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaGet(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Get( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_COMBINED_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Get in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GET_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GET_C ) && HAVE_F08_TS_BUFFERS_MPI_GET_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GET_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Get

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_COMBINED_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size_c(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaGet(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Get( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_COMBINED_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Get_accumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GET_ACCUMULATE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GET_ACCUMULATE ) && HAVE_F08_TS_BUFFERS_MPI_GET_ACCUMULATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GET_ACCUMULATE( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    result_addr, &
    result_count, &
    result_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Get_accumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: result_addr
    INTEGER, INTENT(IN) :: result_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: result_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GET_ACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = result_count * get_datatype_size(result_datatype)
                local_bytes_put = origin_count * get_datatype_size(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_FETCH_AND_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Get_accumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        result_addr, &
        result_count, &
        result_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Get_accumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_GET_ACCUMULATE_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_GET_ACCUMULATE_C ) && HAVE_F08_TS_BUFFERS_MPI_GET_ACCUMULATE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_GET_ACCUMULATE_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    result_addr, &
    result_count, &
    result_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Get_accumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: result_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: result_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: result_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_GET_ACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = result_count * get_datatype_size_c(result_datatype)
                local_bytes_put = origin_count * get_datatype_size_c(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_FETCH_AND_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Get_accumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        result_addr, &
        result_count, &
        result_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Put in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PUT) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PUT ) && HAVE_F08_TS_BUFFERS_MPI_PUT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PUT( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Put

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PUT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaPut(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Put( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Put in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_PUT_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_PUT_C ) && HAVE_F08_TS_BUFFERS_MPI_PUT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_PUT_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST_NULL, &
        MPI_WIN, &
        PMPI_Put

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_PUT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Implicit request may already have a valid matching id
                local_rma_request = scorep_mpi_rma_request_find(local_win_handle, &
                                                                target_rank, &
                                                                MPI_REQUEST_NULL, &
                                                                SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION)
                if (.not. c_associated(local_rma_request)) then
                    local_matching_id = scorep_mpi_get_request_id()
                else
                    local_matching_id = scorep_mpi_rma_request_matching_id(local_rma_request)
                end if
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size_c(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaPut(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Put( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Only implicit request tracking needed
                if (.not. c_associated(local_rma_request)) then
                    local_rma_request = scorep_mpi_rma_request_create(local_win_handle, &
                                                                      target_rank, &
                                                                      MPI_REQUEST_NULL, &
                                                                      SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                                      local_matching_id)
                end if
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Raccumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RACCUMULATE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RACCUMULATE ) && HAVE_F08_TS_BUFFERS_MPI_RACCUMULATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RACCUMULATE( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Raccumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = 0
                local_bytes_put = origin_count * get_datatype_size(origin_datatype)
            end if
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Raccumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Raccumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RACCUMULATE_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RACCUMULATE_C ) && HAVE_F08_TS_BUFFERS_MPI_RACCUMULATE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RACCUMULATE_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Raccumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = 0
                local_bytes_put = origin_count * get_datatype_size_c(origin_datatype)
            end if
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Raccumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rget in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RGET) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RGET ) && HAVE_F08_TS_BUFFERS_MPI_RGET )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RGET( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Rget

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RGET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaGet(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rget( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_COMBINED_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rget in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RGET_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RGET_C ) && HAVE_F08_TS_BUFFERS_MPI_RGET_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RGET_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Rget

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RGET)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size_c(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaGet(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rget( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_COMBINED_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rget_accumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RGET_ACCUMULATE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RGET_ACCUMULATE ) && HAVE_F08_TS_BUFFERS_MPI_RGET_ACCUMULATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RGET_ACCUMULATE( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    result_addr, &
    result_count, &
    result_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Rget_accumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: result_addr
    INTEGER, INTENT(IN) :: result_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: result_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RGET_ACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = result_count * get_datatype_size(result_datatype)
                local_bytes_put = origin_count * get_datatype_size(origin_datatype)
            end if
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_FETCH_AND_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rget_accumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        result_addr, &
        result_count, &
        result_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rget_accumulate in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RGET_ACCUMULATE_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RGET_ACCUMULATE_C ) && HAVE_F08_TS_BUFFERS_MPI_RGET_ACCUMULATE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RGET_ACCUMULATE_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    result_addr, &
    result_count, &
    result_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    op, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_OP, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Rget_accumulate

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: result_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: result_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: result_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_OP), INTENT(IN) :: op
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(c_int64_t) :: local_bytes_put
    integer(c_int64_t) :: local_bytes_get
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RGET_ACCUMULATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_bytes_put = 0
    local_bytes_get = 0
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            if (target_rank .ne. MPI_PROC_NULL) then
                local_bytes_get = result_count * get_datatype_size_c(result_datatype)
                local_bytes_put = origin_count * get_datatype_size_c(origin_datatype)
            end if
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaAtomic(local_win_handle, &
                                      target_rank, &
                                      SCOREP_RMA_ATOMIC_TYPE_FETCH_AND_ACCUMULATE, &
                                      local_bytes_put, &
                                      local_bytes_get, &
                                      local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rget_accumulate( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        result_addr, &
        result_count, &
        result_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        op, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rput in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RPUT) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RPUT ) && HAVE_F08_TS_BUFFERS_MPI_RPUT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RPUT( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Rput

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER, INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER, INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RPUT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaPut(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rput( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Rput in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_RPUT_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_RPUT_C ) && HAVE_F08_TS_BUFFERS_MPI_RPUT_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_RPUT_C( &
    origin_addr, &
    origin_count, &
    origin_datatype, &
    target_rank, &
    target_disp, &
    target_count, &
    target_datatype, &
    win, &
    request, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COUNT_KIND, &
        MPI_DATATYPE, &
        MPI_PROC_NULL, &
        MPI_REQUEST, &
        MPI_WIN, &
        PMPI_Rput

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, INTENT(IN), ASYNCHRONOUS :: origin_addr
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: origin_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: origin_datatype
    INTEGER, INTENT(IN) :: target_rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: target_disp
    INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: target_count
    TYPE(MPI_DATATYPE), INTENT(IN) :: target_datatype
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_REQUEST), INTENT(OUT) :: request
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    type(c_ptr) :: local_rma_request
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_MpiRequestId) :: local_matching_id
    integer(c_int64_t) :: local_origin_bytes

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_RPUT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_rma_request = c_null_ptr
    local_matching_id = 0
    local_origin_bytes = 0_c_int64_t
    local_win_handle = scorep_mpi_win_handle(win)
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            local_matching_id = scorep_mpi_get_request_id()
            if (target_rank .ne. MPI_PROC_NULL) then
                local_origin_bytes = origin_count * get_datatype_size_c(origin_datatype)
            end if
            if (target_rank .ne. MPI_PROC_NULL) then
                call SCOREP_RmaPut(local_win_handle, target_rank, &
                                   local_origin_bytes, &
                                   local_matching_id)
            end if
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Rput( &
        origin_addr, &
        origin_count, &
        origin_datatype, &
        target_rank, &
        target_disp, &
        target_count, &
        target_datatype, &
        win, &
        request, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (target_rank .ne. MPI_PROC_NULL) then
                ! Start implicit request tracking
                local_rma_request = &
                    scorep_mpi_rma_request_create(local_win_handle, &
                                                  target_rank, &
                                                  request, &
                                                  SCOREP_MPI_RMA_REQUEST_SEPARATE_COMPLETION, &
                                                  local_matching_id)
                ! Start explicit request tracking
                call scorep_mpi_request_win_create(request, local_rma_request)
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_allocate in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE ) && HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE( &
    size, &
    disp_unit, &
    info, &
    comm, &
    baseptr, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_INFO, &
        MPI_SUCCESS, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_allocate

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER, INTENT(IN) :: disp_unit
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(C_PTR), INTENT(OUT) :: baseptr
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(c_int64_t), target :: local_size_as_int64

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_ALLOCATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    local_size_as_int64 = 0
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            if (scorep_mpi_memory_recording) then
                local_size_as_int64 = int(size, c_int64_t)
                call SCOREP_AddAttribute(scorep_mpi_memory_alloc_size_attribute, c_loc(local_size_as_int64))
            end if
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_allocate( &
        size, &
        disp_unit, &
        info, &
        comm, &
        baseptr, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_allocate_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            if (scorep_mpi_memory_recording .and. size .gt. 0 .and. MPI_SUCCESS .eq. internal_ierror) then
                call SCOREP_AllocMetric_HandleAlloc(scorep_mpi_allocations_metric, &
                                                    baseptr, &
                                                    int(size, c_size_t))
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE_AND_ALLOCATE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_allocate in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE_C ) && HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE_C( &
    size, &
    disp_unit, &
    info, &
    comm, &
    baseptr, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_INFO, &
        MPI_SUCCESS, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_allocate

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: disp_unit
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(C_PTR), INTENT(OUT) :: baseptr
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(c_int64_t), target :: local_size_as_int64

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_ALLOCATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    local_size_as_int64 = 0
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            if (scorep_mpi_memory_recording) then
                local_size_as_int64 = int(size, c_int64_t)
                call SCOREP_AddAttribute(scorep_mpi_memory_alloc_size_attribute, c_loc(local_size_as_int64))
            end if
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_allocate( &
        size, &
        disp_unit, &
        info, &
        comm, &
        baseptr, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_allocate_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            if (scorep_mpi_memory_recording .and. size .gt. 0 .and. MPI_SUCCESS .eq. internal_ierror) then
                call SCOREP_AllocMetric_HandleAlloc(scorep_mpi_allocations_metric, &
                                                    baseptr, &
                                                    int(size, c_size_t))
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE_AND_ALLOCATE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_allocate_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE_SHARED) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE_SHARED ) && HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE_SHARED )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE_SHARED( &
    size, &
    disp_unit, &
    info, &
    comm, &
    baseptr, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_INFO, &
        MPI_SUCCESS, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_allocate_shared

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER, INTENT(IN) :: disp_unit
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(C_PTR), INTENT(OUT) :: baseptr
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(c_int64_t), target :: local_size_as_int64

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_ALLOCATE_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    local_size_as_int64 = 0
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            if (scorep_mpi_memory_recording) then
                local_size_as_int64 = int(size, c_int64_t)
                call SCOREP_AddAttribute(scorep_mpi_memory_alloc_size_attribute, c_loc(local_size_as_int64))
            end if
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_allocate_shared( &
        size, &
        disp_unit, &
        info, &
        comm, &
        baseptr, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_allocate_shared_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            if (scorep_mpi_memory_recording .and. size .gt. 0 .and. MPI_SUCCESS .eq. internal_ierror) then
                call SCOREP_AllocMetric_HandleAlloc(scorep_mpi_allocations_metric, &
                                                    baseptr, &
                                                    int(size, c_size_t))
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE_AND_ALLOCATE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_allocate_shared in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE_SHARED_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE_SHARED_C ) && HAVE_F08_TS_BUFFERS_MPI_WIN_ALLOCATE_SHARED_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_ALLOCATE_SHARED_C( &
    size, &
    disp_unit, &
    info, &
    comm, &
    baseptr, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_INFO, &
        MPI_SUCCESS, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_allocate_shared

    implicit none

! Dummy argument declarations
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: disp_unit
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(C_PTR), INTENT(OUT) :: baseptr
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(c_int64_t), target :: local_size_as_int64

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_ALLOCATE_SHARED)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    local_size_as_int64 = 0
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            if (scorep_mpi_memory_recording) then
                local_size_as_int64 = int(size, c_int64_t)
                call SCOREP_AddAttribute(scorep_mpi_memory_alloc_size_attribute, c_loc(local_size_as_int64))
            end if
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_allocate_shared( &
        size, &
        disp_unit, &
        info, &
        comm, &
        baseptr, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_allocate_shared_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            if (scorep_mpi_memory_recording .and. size .gt. 0 .and. MPI_SUCCESS .eq. internal_ierror) then
                call SCOREP_AllocMetric_HandleAlloc(scorep_mpi_allocations_metric, &
                                                    baseptr, &
                                                    int(size, c_size_t))
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE_AND_ALLOCATE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_attach in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_ATTACH) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_ATTACH ) && HAVE_F08_TS_BUFFERS_MPI_WIN_ATTACH )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_ATTACH( &
    win, &
    base, &
    size, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_WIN, &
        PMPI_Win_attach

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: base
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_ATTACH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_attach( &
        win, &
        base, &
        size, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_call_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_CALL_ERRHANDLER) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_CALL_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_WIN_CALL_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_CALL_ERRHANDLER( &
    win, &
    errorcode, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_call_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(IN) :: errorcode
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_CALL_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_ERR)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_call_errhandler( &
        win, &
        errorcode, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_complete in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_COMPLETE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_COMPLETE ) && HAVE_F08_TS_BUFFERS_MPI_WIN_COMPLETE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_COMPLETE( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_complete

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_COMPLETE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_complete( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                          c_funloc(scorep_mpi_rma_request_write_standard_completion_and_remove))
            call SCOREP_RmaGroupSync(ior(SCOREP_RMA_SYNC_LEVEL_MEMORY, SCOREP_RMA_SYNC_LEVEL_PROCESS), &
                                     local_win_handle, &
                                     scorep_mpi_epoch_get_group_handle(win, SCOREP_MPI_RMA_ACCESS_EPOCH))
            call scorep_mpi_epoch_end(win, SCOREP_MPI_RMA_ACCESS_EPOCH)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE ) && HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE( &
    base, &
    size, &
    disp_unit, &
    info, &
    comm, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_INFO, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_create

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: base
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER, INTENT(IN) :: disp_unit
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_create( &
        base, &
        size, &
        disp_unit, &
        info, &
        comm, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_create_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_create in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_C ) && HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_C( &
    base, &
    size, &
    disp_unit, &
    info, &
    comm, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_COMM, &
        MPI_INFO, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_create

    implicit none

! Dummy argument declarations
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: base
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: size
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: disp_unit
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_CREATE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_create( &
        base, &
        size, &
        disp_unit, &
        info, &
        comm, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_create_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_create_dynamic in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Triggers five events: Enter, RmaCollectiveBegin, WinCreate,
!> RmaCollectiveEnd, and Leave.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_DYNAMIC) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_DYNAMIC ) && HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_DYNAMIC )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_DYNAMIC( &
    info, &
    comm, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_COMM, &
        MPI_INFO, &
        MPI_WIN, &
        MPI_WIN_NULL, &
        PMPI_Win_create_dynamic

    implicit none

! Dummy argument declarations
    TYPE(MPI_INFO), INTENT(IN) :: info
    TYPE(MPI_COMM), INTENT(IN) :: comm
    TYPE(MPI_WIN), INTENT(OUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_CREATE_DYNAMIC)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_create_dynamic( &
        info, &
        comm, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            if (win .ne. MPI_WIN_NULL) then
                local_win_handle = scorep_mpi_win_create("MPI_Win_create_dynamic_window", win, comm)
                call SCOREP_RmaWinCreate(local_win_handle)
            end if
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_CREATE_HANDLE, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_create_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_ERRHANDLER) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_ERRHANDLER( &
    win_errhandler_fn, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_WIN_ERRHANDLER_FUNCTION, &
        PMPI_Win_create_errhandler

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_WIN_ERRHANDLER_FUNCTION) :: win_errhandler_fn
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_CREATE_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_ERR)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_create_errhandler( &
        win_errhandler_fn, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_detach in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_DETACH) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_DETACH ) && HAVE_F08_TS_BUFFERS_MPI_WIN_DETACH )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_DETACH( &
    win, &
    base, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_detach

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    CHOICE_BUFFER_TYPE, ASYNCHRONOUS :: base
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_DETACH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_detach( &
        win, &
        base, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_fence in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FENCE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FENCE ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FENCE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FENCE( &
    assert, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_fence

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: assert
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FENCE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(ior(SCOREP_RMA_SYNC_LEVEL_MEMORY, SCOREP_RMA_SYNC_LEVEL_PROCESS))
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_fence( &
        assert, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                          c_funloc(scorep_mpi_rma_request_write_standard_completion_and_remove))
            ! TODO: evaluation of assert could lead to better value for the SYNC_LEVEL
            call SCOREP_RmaCollectiveEnd(SCOREP_COLLECTIVE_BARRIER, &
                                         ior(SCOREP_RMA_SYNC_LEVEL_MEMORY, SCOREP_RMA_SYNC_LEVEL_PROCESS), &
                                         local_win_handle, &
                                         SCOREP_INVALID_ROOT_RANK, &
                                         0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_flush in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH( &
    rank, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_flush

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: rank
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FLUSH)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_flush( &
        rank, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_to_target(local_win_handle, &
                                                          rank, &
                                                          c_funloc(scorep_mpi_rma_request_write_full_completion))
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_flush_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH_ALL) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH_ALL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH_ALL( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_flush_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FLUSH_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_flush_all( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                          c_funloc(scorep_mpi_rma_request_write_full_completion))
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_flush_local in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH_LOCAL) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH_LOCAL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH_LOCAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH_LOCAL( &
    rank, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_flush_local

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: rank
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FLUSH_LOCAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_flush_local( &
        rank, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_to_target(local_win_handle, &
                                                          rank, &
                                                          c_funloc(scorep_mpi_rma_request_write_standard_completion))
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_flush_local_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH_LOCAL_ALL) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH_LOCAL_ALL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FLUSH_LOCAL_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FLUSH_LOCAL_ALL( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_flush_local_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FLUSH_LOCAL_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_flush_local_all( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                          c_funloc(scorep_mpi_rma_request_write_standard_completion))
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_free in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FREE) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FREE ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FREE )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FREE( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_free

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(INOUT) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle
    integer(SCOREP_CollectiveType) :: local_collective_type

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FREE)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    local_win_handle = SCOREP_INVALID_RMA_WINDOW
    local_collective_type = SCOREP_COLLECTIVE_DESTROY_HANDLE
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaCollectiveBegin(SCOREP_RMA_SYNC_LEVEL_PROCESS)
            local_collective_type = scorep_mpi_win_collective_type(win)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    local_win_handle = scorep_mpi_win_handle(win)
    call scorep_mpi_win_free(win)
    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_free( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_RmaWinDestroy(local_win_handle)
            call SCOREP_RmaCollectiveEnd(local_collective_type, &
                                         SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                         local_win_handle, SCOREP_INVALID_ROOT_RANK, 0_c_int64_t, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_get_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_ERRHANDLER) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_GET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_WIN_GET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_ERRHANDLER( &
    win, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_WIN, &
        PMPI_Win_get_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_ERRHANDLER), INTENT(OUT) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_GET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_ERR)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_get_errhandler( &
        win, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_get_group in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_GROUP) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_GET_GROUP ) && HAVE_F08_TS_BUFFERS_MPI_WIN_GET_GROUP )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_GROUP( &
    win, &
    group, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_GROUP_NULL, &
        MPI_WIN, &
        PMPI_Win_get_group

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_GROUP), INTENT(OUT) :: group
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_GET_GROUP)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_get_group( &
        win, &
        group, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (group .ne. MPI_GROUP_NULL) then
        call scorep_mpi_group_create(group)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_lock in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_LOCK) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_LOCK ) && HAVE_F08_TS_BUFFERS_MPI_WIN_LOCK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_LOCK( &
    lock_type, &
    rank, &
    assert, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_LOCK_EXCLUSIVE, &
        MPI_WIN, &
        PMPI_Win_lock

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: lock_type
    INTEGER, INTENT(IN) :: rank
    INTEGER, INTENT(IN) :: assert
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_LOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaRequestLock(scorep_mpi_win_handle(win), &
                                       rank, &
                                       0_c_int64_t, &
                                       merge(SCOREP_LOCK_EXCLUSIVE, SCOREP_LOCK_SHARED, lock_type .eq. MPI_LOCK_EXCLUSIVE))
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_lock( &
        lock_type, &
        rank, &
        assert, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_lock_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_LOCK_ALL) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_LOCK_ALL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_LOCK_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_LOCK_ALL( &
    assert, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_lock_all

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: assert
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_LOCK_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call SCOREP_RmaRequestLock(scorep_mpi_win_handle(win), &
                                       SCOREP_ALL_TARGET_RANKS, &
                                       0_c_int64_t, &
                                       SCOREP_LOCK_SHARED)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_lock_all( &
        assert, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_post in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_POST) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_POST ) && HAVE_F08_TS_BUFFERS_MPI_WIN_POST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_POST( &
    group, &
    assert, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_WIN, &
        PMPI_Win_post

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: assert
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_POST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_epoch_start(win, group, SCOREP_MPI_RMA_EXPOSURE_EPOCH)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_post( &
        group, &
        assert, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call SCOREP_RmaGroupSync(SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                     local_win_handle, &
                                     scorep_mpi_group_handle(group))
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_set_errhandler in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_err
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_ERRHANDLER) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_ERR)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SET_ERRHANDLER ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SET_ERRHANDLER )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_ERRHANDLER( &
    win, &
    errhandler, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ERRHANDLER, &
        MPI_WIN, &
        PMPI_Win_set_errhandler

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_ERRHANDLER), INTENT(IN) :: errhandler
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SET_ERRHANDLER)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_ERR)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_set_errhandler( &
        win, &
        errhandler, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_shared_query in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SHARED_QUERY) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SHARED_QUERY ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SHARED_QUERY )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SHARED_QUERY( &
    win, &
    rank, &
    size, &
    disp_unit, &
    baseptr, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_WIN, &
        PMPI_Win_shared_query

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(IN) :: rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: size
    INTEGER, INTENT(OUT) :: disp_unit
    TYPE(C_PTR), INTENT(OUT) :: baseptr
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SHARED_QUERY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_shared_query( &
        win, &
        rank, &
        size, &
        disp_unit, &
        baseptr, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_shared_query in the Fortran 2008 bindings.
!> @note Introduced in MPI 4.0
!> @note Embiggened procedure
!> @ingroup rma
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SHARED_QUERY_C) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SHARED_QUERY_C ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SHARED_QUERY_C )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SHARED_QUERY_C( &
    win, &
    rank, &
    size, &
    disp_unit, &
    baseptr, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_WIN, &
        PMPI_Win_shared_query

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(IN) :: rank
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: size
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: disp_unit
    TYPE(C_PTR), INTENT(OUT) :: baseptr
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SHARED_QUERY)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_shared_query( &
        win, &
        rank, &
        size, &
        disp_unit, &
        baseptr, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_start in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_START) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_START ) && HAVE_F08_TS_BUFFERS_MPI_WIN_START )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_START( &
    group, &
    assert, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_GROUP, &
        MPI_WIN, &
        PMPI_Win_start

    implicit none

! Dummy argument declarations
    TYPE(MPI_GROUP), INTENT(IN) :: group
    INTEGER, INTENT(IN) :: assert
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_START)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
            call scorep_mpi_epoch_start(win, group, SCOREP_MPI_RMA_ACCESS_EPOCH)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_start( &
        group, &
        assert, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call SCOREP_RmaGroupSync(SCOREP_RMA_SYNC_LEVEL_PROCESS, &
                                     local_win_handle, &
                                     scorep_mpi_group_handle(group))
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_sync in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SYNC) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SYNC ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SYNC )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SYNC( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_sync

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SYNC)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_sync( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_test in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_TEST) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_TEST ) && HAVE_F08_TS_BUFFERS_MPI_WIN_TEST )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_TEST( &
    win, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_test

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_TEST)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_test( &
        win, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            if (flag) then
                call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                              c_funloc(scorep_mpi_rma_request_write_standard_completion))
                call SCOREP_RmaGroupSync(ior(SCOREP_RMA_SYNC_LEVEL_MEMORY, SCOREP_RMA_SYNC_LEVEL_PROCESS), &
                                         local_win_handle, &
                                         scorep_mpi_epoch_get_group_handle(win, SCOREP_MPI_RMA_EXPOSURE_EPOCH))
                call scorep_mpi_epoch_end(win, SCOREP_MPI_RMA_EXPOSURE_EPOCH)
            else
                call SCOREP_RmaGroupSync(SCOREP_RMA_SYNC_LEVEL_NONE, &
                                         local_win_handle, &
                                         scorep_mpi_epoch_get_group_handle(win, SCOREP_MPI_RMA_EXPOSURE_EPOCH))
            end if
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_unlock in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_UNLOCK) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_UNLOCK ) && HAVE_F08_TS_BUFFERS_MPI_WIN_UNLOCK )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_UNLOCK( &
    rank, &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_unlock

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(IN) :: rank
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_UNLOCK)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_unlock( &
        rank, &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_to_target(local_win_handle, &
                                                          rank, &
                                                          c_funloc(scorep_mpi_rma_request_write_full_completion))
            call SCOREP_RmaReleaseLock(local_win_handle, rank, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_unlock_all in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_UNLOCK_ALL) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_UNLOCK_ALL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_UNLOCK_ALL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_UNLOCK_ALL( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_unlock_all

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_UNLOCK_ALL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_unlock_all( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                          c_funloc(scorep_mpi_rma_request_write_full_completion))
            call SCOREP_RmaReleaseLock(local_win_handle, SCOREP_ALL_TARGET_RANKS, 0_c_int64_t)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_wait in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_WAIT) && !defined(SCOREP_MPI_NO_RMA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_WAIT ) && HAVE_F08_TS_BUFFERS_MPI_WIN_WAIT )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_WAIT( &
    win, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_wait

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save
    integer(SCOREP_RmaWindowHandle) :: local_win_handle

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_WAIT)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA) .gt&
    &. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_wait( &
        win, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            local_win_handle = scorep_mpi_win_handle(win)
            call scorep_mpi_rma_request_foreach_on_window(local_win_handle, &
                                                          c_funloc(scorep_mpi_rma_request_write_standard_completion_and_remove))
            call SCOREP_RmaGroupSync(ior(SCOREP_RMA_SYNC_LEVEL_MEMORY, SCOREP_RMA_SYNC_LEVEL_PROCESS), &
                                     local_win_handle, &
                                     scorep_mpi_epoch_get_group_handle(win, SCOREP_MPI_RMA_EXPOSURE_EPOCH))
            call scorep_mpi_epoch_end(win, SCOREP_MPI_RMA_EXPOSURE_EPOCH)
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_create_keyval in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_KEYVAL) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXT) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_KEYVAL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_CREATE_KEYVAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_CREATE_KEYVAL( &
    win_copy_attr_fn, &
    win_delete_attr_fn, &
    win_keyval, &
    extra_state, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_WIN_COPY_ATTR_FUNCTION, &
        MPI_WIN_DELETE_ATTR_FUNCTION, &
        PMPI_Win_create_keyval

    implicit none

! Dummy argument declarations
    PROCEDURE(MPI_WIN_COPY_ATTR_FUNCTION) :: win_copy_attr_fn
    PROCEDURE(MPI_WIN_DELETE_ATTR_FUNCTION) :: win_delete_attr_fn
    INTEGER, INTENT(OUT) :: win_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: extra_state
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_CREATE_KEYVAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_create_keyval( &
        win_copy_attr_fn, &
        win_delete_attr_fn, &
        win_keyval, &
        extra_state, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_delete_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_DELETE_ATTR) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXT) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_DELETE_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_WIN_DELETE_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_DELETE_ATTR( &
    win, &
    win_keyval, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_WIN, &
        PMPI_Win_delete_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(IN) :: win_keyval
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_DELETE_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_delete_attr( &
        win, &
        win_keyval, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_free_keyval in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_FREE_KEYVAL) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXT) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_FREE_KEYVAL ) && HAVE_F08_TS_BUFFERS_MPI_WIN_FREE_KEYVAL )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_FREE_KEYVAL( &
    win_keyval, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        PMPI_Win_free_keyval

    implicit none

! Dummy argument declarations
    INTEGER, INTENT(INOUT) :: win_keyval
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_FREE_KEYVAL)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_free_keyval( &
        win_keyval, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_get_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_ATTR) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXT) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_GET_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_WIN_GET_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_ATTR( &
    win, &
    win_keyval, &
    attribute_val, &
    flag, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_WIN, &
        PMPI_Win_get_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(IN) :: win_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: attribute_val
    LOGICAL, INTENT(OUT) :: flag
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_GET_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_get_attr( &
        win, &
        win_keyval, &
        attribute_val, &
        flag, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_get_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_INFO) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_GET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_WIN_GET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_INFO( &
    win, &
    info_used, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_WIN, &
        PMPI_Win_get_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_INFO), INTENT(OUT) :: info_used
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_GET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_get_info( &
        win, &
        info_used, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_get_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_NAME) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_GET_NAME ) && HAVE_F08_TS_BUFFERS_MPI_WIN_GET_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_GET_NAME( &
    win, &
    win_name, &
    resultlen, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_MAX_OBJECT_NAME, &
        MPI_WIN, &
        PMPI_Win_get_name

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    CHARACTER(LEN=MPI_MAX_OBJECT_NAME), INTENT(OUT) :: win_name
    INTEGER, INTENT(OUT) :: resultlen
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_GET_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_get_name( &
        win, &
        win_name, &
        resultlen, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_set_attr in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_ATTR) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA) && !defined(SCOREP_MPI_NO_EXT)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SET_ATTR ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SET_ATTR )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_ATTR( &
    win, &
    win_keyval, &
    attribute_val, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_ADDRESS_KIND, &
        MPI_WIN, &
        PMPI_Win_set_attr

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    INTEGER, INTENT(IN) :: win_keyval
    INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: attribute_val
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SET_ATTR)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_set_attr( &
        win, &
        win_keyval, &
        attribute_val, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_set_info in the Fortran 2008 bindings.
!> @note Introduced in MPI 3.0
!> @ingroup rma_ext
!> Default wrapper: Only enter and exit events are created.
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_INFO) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SET_INFO ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SET_INFO )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_INFO( &
    win, &
    info, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_INFO, &
        MPI_WIN, &
        PMPI_Win_set_info

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    TYPE(MPI_INFO), INTENT(IN) :: info
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SET_INFO)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_set_info( &
        win, &
        info, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!> Measurement wrapper for MPI_Win_set_name in the Fortran 2008 bindings.
!> @note Introduced in MPI 2.0
!> @ingroup rma_ext
!>
#if defined (SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_NAME) && !defined(SCOREP_MPI_NO_RMA) && !defined(SCOREP_MPI_NO_EXT) && !defined(SCOREP_MPI_NO_EXTRA)

#if ( defined( HAVE_F08_TS_BUFFERS_MPI_WIN_SET_NAME ) && HAVE_F08_TS_BUFFERS_MPI_WIN_SET_NAME )
#define CHOICE_BUFFER_TYPE type(*), dimension(..)
#else
#define CHOICE_BUFFER_TYPE type(*), dimension(*)
#endif
subroutine SCOREP_F08_SYMBOL_NAME_MPI_WIN_SET_NAME( &
    win, &
    win_name, &
    ierror)

    use :: scorep_mpi_f08
    use :: mpi_f08, only: &
        MPI_SUCCESS, &
        MPI_WIN, &
        PMPI_Win_set_name

    implicit none

! Dummy argument declarations
    TYPE(MPI_WIN), INTENT(IN) :: win
    CHARACTER(LEN=*), INTENT(IN) :: win_name
    INTEGER, INTENT(OUT), OPTIONAL :: ierror
! Internal replacements for dummy arguments
    INTEGER :: internal_ierror
! Local variable declarations
    integer(kind=SCOREP_InterimCommunicatorHandle) :: regionHandle
    logical :: event_gen_active
    logical :: event_gen_active_for_group
    integer(kind=c_int) :: scorep_in_measurement_save

    call scorep_in_measurement_increment()
    regionHandle = scorep_mpi_regions(SCOREP_MPI_REGION__MPI_WIN_SET_NAME)
    event_gen_active = logical(scorep_mpi_is_event_gen_on())
    event_gen_active_for_group = (logical(scorep_mpi_is_event_gen_on()) .and. (iand(scorep_mpi_enabled, SCOREP_MPI_ENABLED_RMA_EXT)&
    & .gt. 0))
    if (event_gen_active) then
        call scorep_mpi_event_gen_off()
        if (event_gen_active_for_group) then
            call SCOREP_EnterWrappedRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_EnterWrapper(regionHandle)
        end if
    end if

    call scorep_enter_wrapped_region(scorep_in_measurement_save)
    call PMPI_Win_set_name( &
        win, &
        win_name, &
        internal_ierror)
    call scorep_exit_wrapped_region(scorep_in_measurement_save)

    if (internal_ierror .eq. MPI_SUCCESS) then
        call scorep_mpi_win_set_name(win, win_name)
    end if
    if (event_gen_active) then
        if (event_gen_active_for_group) then
            call SCOREP_ExitRegion(regionHandle)
        else if (scorep_is_unwinding_enabled) then
            call SCOREP_ExitWrapper(regionHandle)
        end if
        call scorep_mpi_event_gen_on()
    end if

    if (present(ierror)) then
        ierror = internal_ierror
    end if
    call scorep_in_measurement_decrement()
end subroutine
#undef CHOICE_BUFFER_TYPE
#endif

!>
!>@}
!>
