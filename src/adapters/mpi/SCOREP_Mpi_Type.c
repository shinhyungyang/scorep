/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2013,
 *    RWTH Aachen University, Germany
 *    Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *    Technische Universitaet Dresden, Germany
 *    University of Oregon, Eugene, USA
 *    Forschungszentrum Juelich GmbH, Germany
 *    German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *    Technische Universitaet Muenchen, Germany
 *
 * See the COPYING file in the package base directory for details.
 *
 */

/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
*****************************************************************************
**  Copyright (c) 1998-2011                                                **
**  Forschungszentrum Juelich GmbH, Juelich Supercomputing Centre          **
**                                                                         **
**  Copyright (c) 2010-2011                                                **
**  German Research School for Simulation Sciences GmbH,                   **
**  Laboratory for Parallel Programming                                    **
**                                                                         **
**  Copyright (c) 2003-2008                                                **
**  University of Tennessee, Innovative Computing Laboratory               **
**                                                                         **
**  See the file COPYRIGHT in the package base directory for details       **
****************************************************************************/


/**
 * @file       SCOREP_Mpi_Type.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     alpha
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for datatype functions
 */

#include <config.h>
#include "SCOREP_Mpi.h"
#include <SCOREP_Events.h>

/**
 * @name C wrappers for general functions
 * @{
 */

#if HAVE( DECL_PMPI_PACK ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( MPI_Pack )
/**
 * Measurement wrapper for MPI_Pack
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Pack call with enter and exit events.
 */
int
MPI_Pack( SCOREP_MPI_CONST_DECL void* inbuf, int incount, MPI_Datatype datatype, void* outbuf, int outsize, int* position, MPI_Comm comm )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_PACK ] );

        return_val = PMPI_Pack( inbuf, incount, datatype, outbuf, outsize, position, comm );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_PACK ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack( inbuf, incount, datatype, outbuf, outsize, position, comm );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_PACK_EXTERNAL ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Pack_external )
/**
 * Measurement wrapper for MPI_Pack_external
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Pack_external call with enter and exit events.
 */
int
MPI_Pack_external( SCOREP_MPI_CONST_DECL char* datarep, SCOREP_MPI_CONST_DECL void* inbuf, int incount, MPI_Datatype datatype, void* outbuf, MPI_Aint outsize, MPI_Aint* position )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_PACK_EXTERNAL ] );

        return_val = PMPI_Pack_external( datarep, inbuf, incount, datatype, outbuf, outsize, position );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_PACK_EXTERNAL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack_external( datarep, inbuf, incount, datatype, outbuf, outsize, position );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_PACK_EXTERNAL_SIZE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Pack_external_size )
/**
 * Measurement wrapper for MPI_Pack_external_size
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Pack_external_size call with enter and exit events.
 */
int
MPI_Pack_external_size( SCOREP_MPI_CONST_DECL char* datarep, int incount, MPI_Datatype datatype, MPI_Aint* size )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_PACK_EXTERNAL_SIZE ] );

        return_val = PMPI_Pack_external_size( datarep, incount, datatype, size );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_PACK_EXTERNAL_SIZE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack_external_size( datarep, incount, datatype, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_PACK_SIZE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Pack_size )
/**
 * Measurement wrapper for MPI_Pack_size
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Pack_size call with enter and exit events.
 */
int
MPI_Pack_size( int incount, MPI_Datatype datatype, MPI_Comm comm, int* size )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_PACK_SIZE ] );

        return_val = PMPI_Pack_size( incount, datatype, comm, size );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_PACK_SIZE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack_size( incount, datatype, comm, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_SIZEOF ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Sizeof )
/**
 * Measurement wrapper for MPI_Sizeof
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Sizeof call with enter and exit events.
 */
int
MPI_Sizeof( MPI_Datatype x, int size )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_SIZEOF ] );

        return_val = PMPI_Sizeof( x, size );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_SIZEOF ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Sizeof( x, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_COMMIT ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_commit )
/**
 * Measurement wrapper for MPI_Type_commit
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_commit call with enter and exit events.
 */
int
MPI_Type_commit( MPI_Datatype* datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_COMMIT ] );

        return_val = PMPI_Type_commit( datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_COMMIT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_commit( datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CONTIGUOUS ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_contiguous )
/**
 * Measurement wrapper for MPI_Type_contiguous
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_contiguous call with enter and exit events.
 */
int
MPI_Type_contiguous( int count, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CONTIGUOUS ] );

        return_val = PMPI_Type_contiguous( count, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CONTIGUOUS ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_contiguous( count, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_DARRAY ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_darray )
/**
 * Measurement wrapper for MPI_Type_create_darray
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_darray call with enter and exit events.
 */
int
MPI_Type_create_darray( int size, int rank, int ndims, SCOREP_MPI_CONST_DECL int array_of_gsizes[], SCOREP_MPI_CONST_DECL int array_of_distribs[], SCOREP_MPI_CONST_DECL int array_of_dargs[], SCOREP_MPI_CONST_DECL int array_of_psizes[], int order, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_DARRAY ] );

        return_val = PMPI_Type_create_darray( size, rank, ndims, array_of_gsizes, array_of_distribs, array_of_dargs, array_of_psizes, order, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_DARRAY ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_darray( size, rank, ndims, array_of_gsizes, array_of_distribs, array_of_dargs, array_of_psizes, order, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_HINDEXED ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_hindexed )
/**
 * Measurement wrapper for MPI_Type_create_hindexed
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_hindexed call with enter and exit events.
 */
int
MPI_Type_create_hindexed( int count, SCOREP_MPI_CONST_DECL int array_of_blocklengths[], SCOREP_MPI_CONST_DECL MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_HINDEXED ] );

        return_val = PMPI_Type_create_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_HINDEXED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_HVECTOR ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_hvector )
/**
 * Measurement wrapper for MPI_Type_create_hvector
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_hvector call with enter and exit events.
 */
int
MPI_Type_create_hvector( int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_HVECTOR ] );

        return_val = PMPI_Type_create_hvector( count, blocklength, stride, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_HVECTOR ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_hvector( count, blocklength, stride, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_INDEXED_BLOCK ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_indexed_block )
/**
 * Measurement wrapper for MPI_Type_create_indexed_block
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_indexed_block call with enter and exit events.
 */
int
MPI_Type_create_indexed_block( int count, int blocklength, SCOREP_MPI_CONST_DECL int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_INDEXED_BLOCK ] );

        return_val = PMPI_Type_create_indexed_block( count, blocklength, array_of_displacements, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_INDEXED_BLOCK ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_indexed_block( count, blocklength, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_RESIZED ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_resized )
/**
 * Measurement wrapper for MPI_Type_create_resized
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_resized call with enter and exit events.
 */
int
MPI_Type_create_resized( MPI_Datatype oldtype, MPI_Aint lb, MPI_Aint extent, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_RESIZED ] );

        return_val = PMPI_Type_create_resized( oldtype, lb, extent, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_RESIZED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_resized( oldtype, lb, extent, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_STRUCT ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_struct )
/**
 * Measurement wrapper for MPI_Type_create_struct
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_struct call with enter and exit events.
 */
int
MPI_Type_create_struct( int count, SCOREP_MPI_CONST_DECL int array_of_blocklengths[], SCOREP_MPI_CONST_DECL MPI_Aint array_of_displacements[], SCOREP_MPI_CONST_DECL MPI_Datatype array_of_types[], MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_STRUCT ] );

        return_val = PMPI_Type_create_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_STRUCT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_CREATE_SUBARRAY ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_subarray )
/**
 * Measurement wrapper for MPI_Type_create_subarray
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_subarray call with enter and exit events.
 */
int
MPI_Type_create_subarray( int ndims, SCOREP_MPI_CONST_DECL int array_of_sizes[], SCOREP_MPI_CONST_DECL int array_of_subsizes[], SCOREP_MPI_CONST_DECL int array_of_starts[], int order, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_SUBARRAY ] );

        return_val = PMPI_Type_create_subarray( ndims, array_of_sizes, array_of_subsizes, array_of_starts, order, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_SUBARRAY ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_subarray( ndims, array_of_sizes, array_of_subsizes, array_of_starts, order, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_DUP ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_dup )
/**
 * Measurement wrapper for MPI_Type_dup
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_dup call with enter and exit events.
 */
int
MPI_Type_dup( MPI_Datatype type, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_DUP ] );

        return_val = PMPI_Type_dup( type, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_DUP ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_dup( type, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_EXTENT ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_extent )
/**
 * Measurement wrapper for MPI_Type_extent
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_extent call with enter and exit events.
 */
int
MPI_Type_extent( MPI_Datatype datatype, MPI_Aint* extent )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_EXTENT ] );

        return_val = PMPI_Type_extent( datatype, extent );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_EXTENT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_extent( datatype, extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_FREE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_free )
/**
 * Measurement wrapper for MPI_Type_free
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_free call with enter and exit events.
 */
int
MPI_Type_free( MPI_Datatype* datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_FREE ] );

        return_val = PMPI_Type_free( datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_FREE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_free( datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_GET_CONTENTS ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_get_contents )
/**
 * Measurement wrapper for MPI_Type_get_contents
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_get_contents call with enter and exit events.
 */
int
MPI_Type_get_contents( MPI_Datatype datatype, int max_integers, int max_addresses, int max_datatypes, int array_of_integers[], MPI_Aint array_of_addresses[], MPI_Datatype array_of_datatypes[] )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_CONTENTS ] );

        return_val = PMPI_Type_get_contents( datatype, max_integers, max_addresses, max_datatypes, array_of_integers, array_of_addresses, array_of_datatypes );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_CONTENTS ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_contents( datatype, max_integers, max_addresses, max_datatypes, array_of_integers, array_of_addresses, array_of_datatypes );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_GET_ENVELOPE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_get_envelope )
/**
 * Measurement wrapper for MPI_Type_get_envelope
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_get_envelope call with enter and exit events.
 */
int
MPI_Type_get_envelope( MPI_Datatype datatype, int* num_integers, int* num_addresses, int* num_datatypes, int* combiner )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_ENVELOPE ] );

        return_val = PMPI_Type_get_envelope( datatype, num_integers, num_addresses, num_datatypes, combiner );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_ENVELOPE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_envelope( datatype, num_integers, num_addresses, num_datatypes, combiner );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_GET_EXTENT ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_get_extent )
/**
 * Measurement wrapper for MPI_Type_get_extent
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_get_extent call with enter and exit events.
 */
int
MPI_Type_get_extent( MPI_Datatype datatype, MPI_Aint* lb, MPI_Aint* extent )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_EXTENT ] );

        return_val = PMPI_Type_get_extent( datatype, lb, extent );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_EXTENT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_extent( datatype, lb, extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_GET_TRUE_EXTENT ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_get_true_extent )
/**
 * Measurement wrapper for MPI_Type_get_true_extent
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_get_true_extent call with enter and exit events.
 */
int
MPI_Type_get_true_extent( MPI_Datatype datatype, MPI_Aint* true_lb, MPI_Aint* true_extent )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_TRUE_EXTENT ] );

        return_val = PMPI_Type_get_true_extent( datatype, true_lb, true_extent );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_TRUE_EXTENT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_true_extent( datatype, true_lb, true_extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_HINDEXED ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_hindexed )
/**
 * Measurement wrapper for MPI_Type_hindexed
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_hindexed call with enter and exit events.
 */
int
MPI_Type_hindexed( int count, SCOREP_MPI_CONST_DECL int* array_of_blocklengths, SCOREP_MPI_CONST_DECL MPI_Aint* array_of_displacements, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_HINDEXED ] );

        return_val = PMPI_Type_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_HINDEXED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_HVECTOR ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_hvector )
/**
 * Measurement wrapper for MPI_Type_hvector
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_hvector call with enter and exit events.
 */
int
MPI_Type_hvector( int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_HVECTOR ] );

        return_val = PMPI_Type_hvector( count, blocklength, stride, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_HVECTOR ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_hvector( count, blocklength, stride, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_INDEXED ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_indexed )
/**
 * Measurement wrapper for MPI_Type_indexed
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_indexed call with enter and exit events.
 */
int
MPI_Type_indexed( int count, SCOREP_MPI_CONST_DECL int* array_of_blocklengths, SCOREP_MPI_CONST_DECL int* array_of_displacements, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_INDEXED ] );

        return_val = PMPI_Type_indexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_INDEXED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_indexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_LB ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_lb )
/**
 * Measurement wrapper for MPI_Type_lb
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_lb call with enter and exit events.
 */
int
MPI_Type_lb( MPI_Datatype datatype, MPI_Aint* displacement )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_LB ] );

        return_val = PMPI_Type_lb( datatype, displacement );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_LB ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_lb( datatype, displacement );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_MATCH_SIZE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_match_size )
/**
 * Measurement wrapper for MPI_Type_match_size
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_match_size call with enter and exit events.
 */
int
MPI_Type_match_size( int typeclass, int size, MPI_Datatype* type )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_MATCH_SIZE ] );

        return_val = PMPI_Type_match_size( typeclass, size, type );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_MATCH_SIZE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_match_size( typeclass, size, type );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_SIZE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_size )
/**
 * Measurement wrapper for MPI_Type_size
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_size call with enter and exit events.
 */
int
MPI_Type_size( MPI_Datatype datatype, int* size )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_SIZE ] );

        return_val = PMPI_Type_size( datatype, size );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_SIZE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_size( datatype, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_STRUCT ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_struct )
/**
 * Measurement wrapper for MPI_Type_struct
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_struct call with enter and exit events.
 */
int
MPI_Type_struct( int count, SCOREP_MPI_CONST_DECL int* array_of_blocklengths, SCOREP_MPI_CONST_DECL MPI_Aint* array_of_displacements, SCOREP_MPI_CONST_DECL MPI_Datatype* array_of_types, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_STRUCT ] );

        return_val = PMPI_Type_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_STRUCT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_UB ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_ub )
/**
 * Measurement wrapper for MPI_Type_ub
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_ub call with enter and exit events.
 */
int
MPI_Type_ub( MPI_Datatype datatype, MPI_Aint* displacement )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_UB ] );

        return_val = PMPI_Type_ub( datatype, displacement );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_UB ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_ub( datatype, displacement );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_VECTOR ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_vector )
/**
 * Measurement wrapper for MPI_Type_vector
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_vector call with enter and exit events.
 */
int
MPI_Type_vector( int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_VECTOR ] );

        return_val = PMPI_Type_vector( count, blocklength, stride, oldtype, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_VECTOR ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_vector( count, blocklength, stride, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_UNPACK ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Unpack )
/**
 * Measurement wrapper for MPI_Unpack
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Unpack call with enter and exit events.
 */
int
MPI_Unpack( SCOREP_MPI_CONST_DECL void* inbuf, int insize, int* position, void* outbuf, int outcount, MPI_Datatype datatype, MPI_Comm comm )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_UNPACK ] );

        return_val = PMPI_Unpack( inbuf, insize, position, outbuf, outcount, datatype, comm );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_UNPACK ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Unpack( inbuf, insize, position, outbuf, outcount, datatype, comm );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_UNPACK_EXTERNAL ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Unpack_external )
/**
 * Measurement wrapper for MPI_Unpack_external
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Unpack_external call with enter and exit events.
 */
int
MPI_Unpack_external( SCOREP_MPI_CONST_DECL char* datarep, SCOREP_MPI_CONST_DECL void* inbuf, MPI_Aint insize, MPI_Aint* position, void* outbuf, int outcount, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_UNPACK_EXTERNAL ] );

        return_val = PMPI_Unpack_external( datarep, inbuf, insize, position, outbuf, outcount, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_UNPACK_EXTERNAL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Unpack_external( datarep, inbuf, insize, position, outbuf, outcount, datatype );
    }

    return return_val;
}
#endif


#if HAVE( MPI_TYPE_CREATE_F90_COMPLEX_COMPLIANT )
#if HAVE( DECL_PMPI_TYPE_CREATE_F90_COMPLEX ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_f90_complex )
/**
 * Measurement wrapper for MPI_Type_create_f90_complex
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_StdCompl.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_f90_complex call with enter and exit events.
 */
int
MPI_Type_create_f90_complex( int p, int r, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_F90_COMPLEX ] );

        return_val = PMPI_Type_create_f90_complex( p, r, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_F90_COMPLEX ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_f90_complex( p, r, newtype );
    }

    return return_val;
}
#endif
#endif

#if HAVE( MPI_TYPE_CREATE_F90_INTEGER_COMPLIANT )
#if HAVE( DECL_PMPI_TYPE_CREATE_F90_INTEGER ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_f90_integer )
/**
 * Measurement wrapper for MPI_Type_create_f90_integer
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_StdCompl.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_f90_integer call with enter and exit events.
 */
int
MPI_Type_create_f90_integer( int r, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_F90_INTEGER ] );

        return_val = PMPI_Type_create_f90_integer( r, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_F90_INTEGER ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_f90_integer( r, newtype );
    }

    return return_val;
}
#endif
#endif

#if HAVE( MPI_TYPE_CREATE_F90_REAL_COMPLIANT )
#if HAVE( DECL_PMPI_TYPE_CREATE_F90_REAL ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( MPI_Type_create_f90_real )
/**
 * Measurement wrapper for MPI_Type_create_f90_real
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_StdCompl.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_f90_real call with enter and exit events.
 */
int
MPI_Type_create_f90_real( int p, int r, MPI_Datatype* newtype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_F90_REAL ] );

        return_val = PMPI_Type_create_f90_real( p, r, newtype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_F90_REAL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_f90_real( p, r, newtype );
    }

    return return_val;
}
#endif
#endif


/**
 * @}
 * @name C wrappers for external interface functions
 * @{
 */

#if HAVE( DECL_PMPI_TYPE_CREATE_KEYVAL ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_create_keyval )
/**
 * Measurement wrapper for MPI_Type_create_keyval
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_create_keyval call with enter and exit events.
 */
int
MPI_Type_create_keyval( MPI_Type_copy_attr_function* type_copy_attr_fn, MPI_Type_delete_attr_function* type_delete_attr_fn, int* type_keyval, void* extra_state )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_KEYVAL ] );

        return_val = PMPI_Type_create_keyval( type_copy_attr_fn, type_delete_attr_fn, type_keyval, extra_state );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_CREATE_KEYVAL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_keyval( type_copy_attr_fn, type_delete_attr_fn, type_keyval, extra_state );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_DELETE_ATTR ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_delete_attr )
/**
 * Measurement wrapper for MPI_Type_delete_attr
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_delete_attr call with enter and exit events.
 */
int
MPI_Type_delete_attr( MPI_Datatype type, int type_keyval )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_DELETE_ATTR ] );

        return_val = PMPI_Type_delete_attr( type, type_keyval );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_DELETE_ATTR ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_delete_attr( type, type_keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_FREE_KEYVAL ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_free_keyval )
/**
 * Measurement wrapper for MPI_Type_free_keyval
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_free_keyval call with enter and exit events.
 */
int
MPI_Type_free_keyval( int* type_keyval )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_FREE_KEYVAL ] );

        return_val = PMPI_Type_free_keyval( type_keyval );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_FREE_KEYVAL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_free_keyval( type_keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_GET_ATTR ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_get_attr )
/**
 * Measurement wrapper for MPI_Type_get_attr
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_get_attr call with enter and exit events.
 */
int
MPI_Type_get_attr( MPI_Datatype type, int type_keyval, void* attribute_val, int* flag )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_ATTR ] );

        return_val = PMPI_Type_get_attr( type, type_keyval, attribute_val, flag );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_ATTR ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_attr( type, type_keyval, attribute_val, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_GET_NAME ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_get_name )
/**
 * Measurement wrapper for MPI_Type_get_name
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_get_name call with enter and exit events.
 */
int
MPI_Type_get_name( MPI_Datatype type, char* type_name, int* resultlen )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_NAME ] );

        return_val = PMPI_Type_get_name( type, type_name, resultlen );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_GET_NAME ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_name( type, type_name, resultlen );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_SET_ATTR ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_set_attr )
/**
 * Measurement wrapper for MPI_Type_set_attr
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_set_attr call with enter and exit events.
 */
int
MPI_Type_set_attr( MPI_Datatype type, int type_keyval, void* attribute_val )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_SET_ATTR ] );

        return_val = PMPI_Type_set_attr( type, type_keyval, attribute_val );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_SET_ATTR ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_set_attr( type, type_keyval, attribute_val );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_TYPE_SET_NAME ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_TYPE ) && !defined( SCOREP_MPI_NO_EXT ) && !defined( MPI_Type_set_name )
/**
 * Measurement wrapper for MPI_Type_set_name
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the MPI_Type_set_name call with enter and exit events.
 */
int
MPI_Type_set_name( MPI_Datatype type, SCOREP_MPI_CONST_DECL char* type_name )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_TYPE_EXT ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_SET_NAME ] );

        return_val = PMPI_Type_set_name( type, type_name );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_TYPE_SET_NAME ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_set_name( type, type_name );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for handle conversion functions
 * @{
 */


/**
 * @}
 */
