/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2013,
 *    RWTH Aachen University, Germany
 *    Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *    Technische Universitaet Dresden, Germany
 *    University of Oregon, Eugene, USA
 *    Forschungszentrum Juelich GmbH, Germany
 *    German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *    Technische Universitaet Muenchen, Germany
 *
 * See the COPYING file in the package base directory for details.
 *
 */

/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
*****************************************************************************
**  Copyright (c) 1998-2011                                                **
**  Forschungszentrum Juelich GmbH, Juelich Supercomputing Centre          **
**                                                                         **
**  Copyright (c) 2010-2011                                                **
**  German Research School for Simulation Sciences GmbH,                   **
**  Laboratory for Parallel Programming                                    **
**                                                                         **
**  Copyright (c) 2003-2008                                                **
**  University of Tennessee, Innovative Computing Laboratory               **
**                                                                         **
**  See the file COPYRIGHT in the package base directory for details       **
****************************************************************************/


/**
 * @file       SCOREP_Mpi_Misc.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     alpha
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for miscelaneous and handler conversion
 *        functions
 */

#include <config.h>
#include "SCOREP_Mpi.h"
#include <SCOREP_Events.h>

/**
 * @name C wrappers
 * @{
 */

#if HAVE( DECL_PMPI_ADDRESS ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Address )
/**
 * Measurement wrapper for MPI_Address
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Address call with enter and exit events.
 */
int
MPI_Address( SCOREP_MPI_CONST_DECL void* location, MPI_Aint* address )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_ADDRESS ] );

        return_val = PMPI_Address( location, address );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_ADDRESS ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Address( location, address );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_ALLOC_MEM ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Alloc_mem )
/**
 * Measurement wrapper for MPI_Alloc_mem
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Alloc_mem call with enter and exit events.
 */
int
MPI_Alloc_mem( MPI_Aint size, MPI_Info info, void* baseptr )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_ALLOC_MEM ] );

        return_val = PMPI_Alloc_mem( size, info, baseptr );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_ALLOC_MEM ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Alloc_mem( size, info, baseptr );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FREE_MEM ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Free_mem )
/**
 * Measurement wrapper for MPI_Free_mem
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Free_mem call with enter and exit events.
 */
int
MPI_Free_mem( void* base )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FREE_MEM ] );

        return_val = PMPI_Free_mem( base );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FREE_MEM ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Free_mem( base );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_GET_ADDRESS ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Get_address )
/**
 * Measurement wrapper for MPI_Get_address
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Get_address call with enter and exit events.
 */
int
MPI_Get_address( SCOREP_MPI_CONST_DECL void* location, MPI_Aint* address )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_GET_ADDRESS ] );

        return_val = PMPI_Get_address( location, address );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_GET_ADDRESS ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Get_address( location, address );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_GET_VERSION ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Get_version )
/**
 * Measurement wrapper for MPI_Get_version
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Get_version call with enter and exit events.
 */
int
MPI_Get_version( int* version, int* subversion )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_GET_VERSION ] );

        return_val = PMPI_Get_version( version, subversion );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_GET_VERSION ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Get_version( version, subversion );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_OP_COMMUTATIVE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Op_commutative )
/**
 * Measurement wrapper for MPI_Op_commutative
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Op_commutative call with enter and exit events.
 */
int
MPI_Op_commutative( MPI_Op op, int* commute )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_OP_COMMUTATIVE ] );

        return_val = PMPI_Op_commutative( op, commute );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_OP_COMMUTATIVE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Op_commutative( op, commute );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_OP_CREATE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Op_create )
/**
 * Measurement wrapper for MPI_Op_create
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Op_create call with enter and exit events.
 */
int
MPI_Op_create( MPI_User_function* function, int commute, MPI_Op* op )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_OP_CREATE ] );

        return_val = PMPI_Op_create( function, commute, op );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_OP_CREATE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Op_create( function, commute, op );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_OP_FREE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Op_free )
/**
 * Measurement wrapper for MPI_Op_free
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Op_free call with enter and exit events.
 */
int
MPI_Op_free( MPI_Op* op )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_OP_FREE ] );

        return_val = PMPI_Op_free( op );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_OP_FREE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Op_free( op );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_REQUEST_GET_STATUS ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Request_get_status )
/**
 * Measurement wrapper for MPI_Request_get_status
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Request_get_status call with enter and exit events.
 */
int
MPI_Request_get_status( MPI_Request request, int* flag, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_REQUEST_GET_STATUS ] );

        return_val = PMPI_Request_get_status( request, flag, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_REQUEST_GET_STATUS ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Request_get_status( request, flag, status );
    }

    return return_val;
}
#endif


#if HAVE( DECL_PMPI_INFO_C2F ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_c2f )
/**
 * Measurement wrapper for MPI_Info_c2f
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_c2f call with enter and exit events.
 */
MPI_Fint
MPI_Info_c2f( MPI_Info info )
{
    MPI_Fint return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_C2F ] );

        return_val = PMPI_Info_c2f( info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_C2F ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_c2f( info );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_INFO_CREATE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_create )
/**
 * Measurement wrapper for MPI_Info_create
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_create call with enter and exit events.
 */
int
MPI_Info_create( MPI_Info* info )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_CREATE ] );

        return_val = PMPI_Info_create( info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_CREATE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_create( info );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_INFO_DUP ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_dup )
/**
 * Measurement wrapper for MPI_Info_dup
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_dup call with enter and exit events.
 */
int
MPI_Info_dup( MPI_Info info, MPI_Info* newinfo )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_DUP ] );

        return_val = PMPI_Info_dup( info, newinfo );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_DUP ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_dup( info, newinfo );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_INFO_F2C ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_f2c )
/**
 * Measurement wrapper for MPI_Info_f2c
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_f2c call with enter and exit events.
 */
MPI_Info
MPI_Info_f2c( MPI_Fint info )
{
    MPI_Info return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_F2C ] );

        return_val = PMPI_Info_f2c( info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_F2C ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_f2c( info );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_INFO_FREE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_free )
/**
 * Measurement wrapper for MPI_Info_free
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_free call with enter and exit events.
 */
int
MPI_Info_free( MPI_Info* info )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_FREE ] );

        return_val = PMPI_Info_free( info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_FREE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_free( info );
    }

    return return_val;
}
#endif


#if HAVE( MPI_INFO_DELETE_COMPLIANT )
#if HAVE( DECL_PMPI_INFO_DELETE ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_delete )
/**
 * Measurement wrapper for MPI_Info_delete
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_delete call with enter and exit events.
 */
int
MPI_Info_delete( MPI_Info info, SCOREP_MPI_CONST_DECL char* key )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_DELETE ] );

        return_val = PMPI_Info_delete( info, key );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_DELETE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_delete( info, key );
    }

    return return_val;
}
#endif
#endif

#if HAVE( MPI_INFO_GET_COMPLIANT )
#if HAVE( DECL_PMPI_INFO_GET ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_get )
/**
 * Measurement wrapper for MPI_Info_get
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_get call with enter and exit events.
 */
int
MPI_Info_get( MPI_Info info, SCOREP_MPI_CONST_DECL char* key, int valuelen, char* value, int* flag )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_GET ] );

        return_val = PMPI_Info_get( info, key, valuelen, value, flag );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_GET ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_get( info, key, valuelen, value, flag );
    }

    return return_val;
}
#endif
#endif

#if HAVE( MPI_INFO_GET_VALUELEN_COMPLIANT )
#if HAVE( DECL_PMPI_INFO_GET_VALUELEN ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_get_valuelen )
/**
 * Measurement wrapper for MPI_Info_get_valuelen
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_get_valuelen call with enter and exit events.
 */
int
MPI_Info_get_valuelen( MPI_Info info, SCOREP_MPI_CONST_DECL char* key, int* valuelen, int* flag )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_GET_VALUELEN ] );

        return_val = PMPI_Info_get_valuelen( info, key, valuelen, flag );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_GET_VALUELEN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_get_valuelen( info, key, valuelen, flag );
    }

    return return_val;
}
#endif
#endif

#if HAVE( MPI_INFO_SET_COMPLIANT )
#if HAVE( DECL_PMPI_INFO_SET ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_MISC ) && !defined( MPI_Info_set )
/**
 * Measurement wrapper for MPI_Info_set
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup misc
 * Triggers an enter and exit event.
 * It wraps the MPI_Info_set call with enter and exit events.
 */
int
MPI_Info_set( MPI_Info info, SCOREP_MPI_CONST_DECL char* key, SCOREP_MPI_CONST_DECL char* value )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_MISC ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_SET ] );

        return_val = PMPI_Info_set( info, key, value );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_INFO_SET ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Info_set( info, key, value );
    }

    return return_val;
}
#endif
#endif

/**
 * @}
 */
