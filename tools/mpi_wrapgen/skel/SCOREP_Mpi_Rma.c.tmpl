/**
 * @file
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for one-sided communication
 */

#include <config.h>

#include "SCOREP_Mpi.h"
#include "scorep_mpi_communicator.h"
#include <SCOREP_RuntimeManagement.h>
#include <SCOREP_InMeasurement.h>
#include <SCOREP_Events.h>

/** internal id counter for rma operations */
static int scorep_rma_id = 0;

/** current rma id to use in event generation */
#define SCOREP_CURR_RMA_ID   scorep_rma_id
/** increment and get rma id to use in event generation */
#define SCOREP_NEXT_RMA_ID ++scorep_rma_id

/**
 * @name C wrappers for access functions
 * @{
 */

#pragma wrapgen single MPI_Accumulate skel/SCOREP_Mpi_RmaPut.w
#pragma wrapgen single MPI_Compare_and_swap skel/SCOREP_Mpi_StdWithProto.w
#pragma wrapgen single MPI_Fetch_and_op skel/SCOREP_Mpi_StdWithProto.w

#if HAVE(DECL_PMPI_GET) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Get
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Get(void*        origin_addr,
            int          origin_count,
            MPI_Datatype origin_datatype,
            int          target_rank,
            MPI_Aint     target_disp,
            int          target_count,
            MPI_Datatype target_datatype,
            MPI_Win      win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
/* One-sided communication not handled in first version
    int32_t              sendsz;
    SCOREP_MpiRank        dest_proc_rank;
    SCOREP_RmaWindowHandle win_handle;
*/

    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_GET]);

/* One-sided communication not handled in first version
    dest_proc_rank = scorep_mpi_win_rank_to_pe( target_rank, win );
    win_handle = scorep_mpi_win_id( win );
*/
    /* in MPI_GET the target buffer is remote */
/* One-sided communication not handled in first version
    PMPI_Type_size(target_datatype, &sendsz);
    esd_mpi_get_1ts_remote(dest_proc_rank, win_handle, SCOREP_NEXT_RMA_ID, target_count * sendsz);
*/
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_GET]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Get( origin_addr, origin_count,
                origin_datatype, target_rank, target_disp,
                target_count, target_datatype, win );
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
    /* in MPI_GET the origin buffer is local */
/* One-sided communication not handled in first version
    esd_mpi_get_1te( dest_proc_rank, win_handle, SCOREP_CURR_RMA_ID);
*/
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_GET]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_GET]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Get_accumulate skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Put skel/SCOREP_Mpi_RmaPut.w
#pragma wrapgen single MPI_Raccumulate skel/SCOREP_Mpi_StdWithProto.w
#pragma wrapgen single MPI_Rget skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Rget_accumulate skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Rput skel/SCOREP_Mpi_Std.w

/**
 * @}
 * @name C wrappers for window management functions
 * @{
 */

#if HAVE( DECL_PMPI_WIN_ALLOCATE ) && !defined( SCOREP_MPI_NO_RMA ) && !defined( MPI_Win_allocate )
/**
 * Measurement wrapper for MPI_Win_allocate
 * @note C interface
 * @note Introduced with MPI-3
 * @ingroup rma
 * Triggers an enter and exit event.
 * It wraps the MPI_Win_allocate call with enter and exit events.
 */
int
MPI_Win_allocate( MPI_Aint size, int disp_unit, MPI_Info info, MPI_Comm comm, void* baseptr, MPI_Win* win )
{
    SCOREP_IN_MEASUREMENT_INCREMENT();
    const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
    const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
    int       return_val;

    if ( event_gen_active )
    {
        SCOREP_MPI_EVENT_GEN_OFF();

        if ( event_gen_active_for_group )
        {
            if ( scorep_mpi_memory_recording )
            {
                uint64_t size_as_uint64 = size;
                SCOREP_AddAttribute( scorep_mpi_memory_alloc_size_attribute,
                                     &size_as_uint64 );
            }

            SCOREP_EnterWrappedRegion( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE ] );
        }
        else if ( SCOREP_IsUnwindingEnabled() )
        {
            SCOREP_EnterWrapper( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE ] );
        }
    }

    SCOREP_ENTER_WRAPPED_REGION();
    return_val = PMPI_Win_allocate( size, disp_unit, info, comm, baseptr, win );
    SCOREP_EXIT_WRAPPED_REGION();

    if ( event_gen_active )
    {
        if (event_gen_active_for_group)
        {
            if ( scorep_mpi_memory_recording && size > 0 && MPI_SUCCESS == return_val )
            {
                SCOREP_AllocMetric_HandleAlloc( scorep_mpi_allocations_metric,
                                                ( uint64_t )( *( void** )baseptr ),
                                                size );
            }

            SCOREP_ExitRegion( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE ] );
        }
        else if ( SCOREP_IsUnwindingEnabled() )
        {
            SCOREP_ExitWrapper( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE ] );
        }
        SCOREP_MPI_EVENT_GEN_ON();
    }

    SCOREP_IN_MEASUREMENT_DECREMENT();
    return return_val;
}
#endif

#if HAVE( DECL_PMPI_WIN_ALLOCATE_SHARED ) && !defined( SCOREP_MPI_NO_RMA ) && !defined( MPI_Win_allocate_shared )
/**
 * Measurement wrapper for MPI_Win_allocate_shared
 * @note C interface
 * @note Introduced with MPI-3
 * @ingroup rma
 * Triggers an enter and exit event.
 * It wraps the MPI_Win_allocate_shared call with enter and exit events.
 */
int
MPI_Win_allocate_shared( MPI_Aint size, int disp_unit, MPI_Info info, MPI_Comm comm, void* baseptr, MPI_Win* win )
{
    SCOREP_IN_MEASUREMENT_INCREMENT();
    const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
    const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
    int       return_val;

    if ( event_gen_active )
    {
        SCOREP_MPI_EVENT_GEN_OFF();

        if ( event_gen_active_for_group )
        {
            if ( scorep_mpi_memory_recording )
            {
                uint64_t size_as_uint64 = size;
                SCOREP_AddAttribute( scorep_mpi_memory_alloc_size_attribute,
                                     &size_as_uint64 );
            }

            SCOREP_EnterWrappedRegion( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE_SHARED ] );
        }
        else if ( SCOREP_IsUnwindingEnabled() )
        {
            SCOREP_EnterWrapper( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE_SHARED ] );
        }
    }

    SCOREP_ENTER_WRAPPED_REGION();
    return_val = PMPI_Win_allocate_shared( size, disp_unit, info, comm, baseptr, win );
    SCOREP_EXIT_WRAPPED_REGION();

    if (event_gen_active)
    {
        if ( event_gen_active_for_group )
        {
            if ( scorep_mpi_memory_recording && size > 0 && MPI_SUCCESS == return_val )
            {
                SCOREP_AllocMetric_HandleAlloc( scorep_mpi_allocations_metric,
                                                ( uint64_t )( *( void** )baseptr ),
                                                size );
            }

            SCOREP_ExitRegion( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE_SHARED ] );
        }
        else if ( SCOREP_IsUnwindingEnabled() )
        {
            SCOREP_ExitWrapper( scorep_mpi_regions[ SCOREP_MPI_REGION__MPI_WIN_ALLOCATE_SHARED ] );
        }
        SCOREP_MPI_EVENT_GEN_ON();
    }

    SCOREP_IN_MEASUREMENT_DECREMENT();
    return return_val;
}
#endif

#pragma wrapgen single MPI_Win_attach skel/SCOREP_Mpi_Std.w

#if HAVE(DECL_PMPI_WIN_CREATE) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_create
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_create(void*    base,
                   MPI_Aint size,
                   int      disp_unit,
                   MPI_Info info,
                   MPI_Comm comm,
                   MPI_Win* win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_CREATE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_CREATE]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_create(base, size, disp_unit,
                info, comm, win );
  SCOREP_EXIT_WRAPPED_REGION();

/* One-sided communication not handled in first version
  if (*win != MPI_WIN_NULL)
  {
    scorep_mpi_win_rank_create( *win, comm );
  }
*/

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_CREATE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_CREATE]);
    }
    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_create_dynamic skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Win_detach skel/SCOREP_Mpi_StdWithProto.w

#if HAVE(DECL_PMPI_WIN_FREE) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_free
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_free(MPI_Win* win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int           event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int           event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int                 return_val;
/* One-sided communication not handled in first version
  SCOREP_RmaWindowHandle win_handle;
*/

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FREE]);

/* One-sided communication not handled in first version
    win_handle = scorep_mpi_win_rank_id(*win);
*/
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FREE]);
    }
  }

/* One-sided communication not handled in first version
  scorep_mpi_win_rank_free(*win);
*/

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_free( win );
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FREE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FREE]);
    }
    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_shared_query skel/SCOREP_Mpi_Std.w

/**
 * @}
 * @name C wrappers for synchronization functions
 * @{
 */

#if HAVE(DECL_PMPI_WIN_COMPLETE) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_complete
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_complete(MPI_Win win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_COMPLETE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_COMPLETE]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_complete(win);
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_COMPLETE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_COMPLETE]);
    }
    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#if HAVE(DECL_PMPI_WIN_FENCE) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_fence
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_fence(int     assert,
                  MPI_Win win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FENCE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FENCE]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_fence(assert, win);
  SCOREP_EXIT_WRAPPED_REGION();


  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FENCE]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_FENCE]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_flush skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Win_flush_all skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Win_flush_local skel/SCOREP_Mpi_Std.w
#pragma wrapgen single MPI_Win_flush_local_all skel/SCOREP_Mpi_Std.w

#if HAVE(DECL_PMPI_WIN_LOCK) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_lock
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_lock(int     lock_type,
                 int     rank,
                 int     assert,
                 MPI_Win win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int   return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_LOCK]);

/* One-sided communication not handled in first version
      esd_mpi_win_lock( rank, scorep_mpi_win_rank_id(win), lock_type==MPI_LOCK_EXCLUSIVE);
*/
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_LOCK]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_lock( lock_type, rank,
                    assert, win );
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_LOCK]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_LOCK]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }
  else

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_lock_all skel/SCOREP_Mpi_Std.w

#if HAVE(DECL_PMPI_WIN_POST) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_post
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_post(MPI_Group group,
                 int       assert,
                 MPI_Win   win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_POST]);

/* One-sided communication not handled in first version
      scorep_mpi_winacc_start(win, group, 0);
*/
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_POST]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_post(group, assert, win);
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_POST]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_POST]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#if HAVE(DECL_PMPI_WIN_START) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_start
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_start(MPI_Group group,
                  int       assert,
                  MPI_Win   win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_START]);

/* One-sided communication not handled in first version
      scorep_mpi_winacc_start(win, group, 1);
*/
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_START]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_start(group, assert, win);
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_START]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_START]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }
  else

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_sync skel/SCOREP_Mpi_Std.w

#if HAVE(DECL_PMPI_WIN_TEST) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_test
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_test(MPI_Win win,
                 int*    flag)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_TEST]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_TEST]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_test(win, flag);
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
/* One-sided communication not handled in first version
      if (*flag != 0)
      {
        esd_mpi_winexit(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_TEST],
                        scorep_mpi_win_rank_id(win), scorep_mpi_winacc_get_gid(win, 0), 1);
        scorep_mpi_winacc_end(win, 0);
      }
      else
      {
        esd_mpi_winexit(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_TEST],
                        scorep_mpi_win_rank_id(win), scorep_mpi_winacc_get_gid(win, 0), 0);
      }
*/
      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_TEST]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_TEST]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#if HAVE(DECL_PMPI_WIN_UNLOCK) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_unlock
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_unlock(int     rank,
                   MPI_Win win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_UNLOCK]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_UNLOCK]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_unlock(rank, win);
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
/* One-sided communication not handled in first version
      esd_mpi_win_unlock(rank, scorep_mpi_win_rank_id(win));
*/

      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_UNLOCK]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_UNLOCK]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_unlock_all skel/SCOREP_Mpi_Std.w

#if HAVE(DECL_PMPI_WIN_WAIT) && !defined(SCOREP_MPI_NO_RMA)
/**
 * Measurement wrapper for MPI_Win_wait
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 * Triggers an enter and exit event.
 */
int MPI_Win_wait(MPI_Win win)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  const int event_gen_active           = SCOREP_MPI_IS_EVENT_GEN_ON;
  const int event_gen_active_for_group = SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_RMA);
  int       return_val;

  if (event_gen_active)
  {
    SCOREP_MPI_EVENT_GEN_OFF();

    if (event_gen_active_for_group)
    {
      SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_WAIT]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_EnterWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_WAIT]);
    }
  }

  SCOREP_ENTER_WRAPPED_REGION();
  return_val = PMPI_Win_wait(win);
  SCOREP_EXIT_WRAPPED_REGION();

  if (event_gen_active)
  {
    if (event_gen_active_for_group)
    {
/* One-sided communication not handled in first version
      esd_mpi_winexit(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_WAIT],
                      scorep_mpi_win_rank_id(win), scorep_mpi_winacc_get_gid(win, 0), 1);
      scorep_mpi_winacc_end(win, 0);
*/

      SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_WAIT]);
    }
    else if ( SCOREP_IsUnwindingEnabled() )
    {
      SCOREP_ExitWrapper(scorep_mpi_regions[SCOREP_MPI_REGION__MPI_WIN_WAIT]);
    }

    SCOREP_MPI_EVENT_GEN_ON();
  }

  SCOREP_IN_MEASUREMENT_DECREMENT();
  return return_val;
}
#endif

#pragma wrapgen single MPI_Win_get_group skel/SCOREP_Mpi_Group.w

/**
 * @}
 * @name C wrappers for error handling functions
 * @{
 */
#pragma wrapgen multiple restrict(grma_err)  skel/SCOREP_Mpi_Std.w

/**
 * @}
 * @name C wrappers for external interface functions
 * @{
 */
#pragma wrapgen multiple restrict(grma_ext)  skel/SCOREP_Mpi_Std.w

/**
 * @}
 * @name C wrappers for handle conversion functions
 * @{
 */
#pragma wrapgen multiple restrict(grma_misc) skel/SCOREP_Mpi_Std.w

/**
 * @}
 */
