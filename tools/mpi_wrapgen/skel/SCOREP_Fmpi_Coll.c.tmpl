/**
 * @file
 * @ingroup    MPI_Wrapper
 *
 * @brief Fortran interface wrappers for collective communication
 */

#include <config.h>
#include "SCOREP_Fmpi.h"

/* uppercase defines */
#pragma wrapgen multiple restrict(gcoll) skel/SCOREP_Fmpi_DefineU.w

/* lowercase defines */
#pragma wrapgen multiple restrict(gcoll) skel/SCOREP_Fmpi_DefineL.w

/**
 * @name Fortran wrappers
 * @{
 */

#ifndef NEED_F2C_CONV

/* If MPI_Comm_f2c is HAVE as a simple macro (which typically does nothing)
 * as it would require a "real" function if it is really needed
 * => we can save the f2c and c2s conversions */

#pragma wrapgen multiple restrict(gcoll) skel/SCOREP_Fmpi_Std.w

#else /* !NEED_F2C_CONV */

#pragma wrapgen multiple restrict(v1+gcoll) skel/SCOREP_Mpi_F2c_C2f.w

#if HAVE(DECL_PMPI_ALLTOALLW) && ! defined(SCOREP_MPI_NO_COLL)
/**
 * Measurement wrapper for MPI_Alltoallw
 * @note Manually created wrapper
 * @note Fortran interface
 * @note Introduced with MPI 1.0
 * @ingroup coll
 */
void FSUB(MPI_Alltoallw)(void*     sendbuf,
                         MPI_Fint* sendcounts,
                         MPI_Fint* sdispls,
                         MPI_Fint* sendtypes,
                         void*     recvbuf,
                         MPI_Fint* recvcounts,
                         MPI_Fint* rdispls,
                         MPI_Fint* recvtypes,
                         MPI_Fint* comm,
                         MPI_Fint* ierr)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  MPI_Datatype* csendtypes;
  MPI_Datatype* crecvtypes;
  MPI_Comm      ccomm;
  int           size;

  #if HAVE(MPI_IN_PLACE)
  if (sendbuf == scorep_mpi_fortran_in_place)
  {
    sendbuf = MPI_IN_PLACE;
  }
  #endif
  #if HAVE(MPI_BOTTOM)
  if (sendbuf == scorep_mpi_fortran_bottom)
  {
    sendbuf = MPI_BOTTOM;
  }
  #endif
  #if HAVE(MPI_BOTTOM)
  if (recvbuf == scorep_mpi_fortran_bottom)
  {
    recvbuf = MPI_BOTTOM;
  }
  #endif

  ccomm = PMPI_Comm_f2c(*comm);
  PMPI_Comm_size(ccomm, &size);

  csendtypes = malloc(size * sizeof(MPI_Datatype));
  crecvtypes = malloc(size * sizeof(MPI_Datatype));

  while (size > 0)
  {
    csendtypes[size-1] = PMPI_Type_f2c(sendtypes[size-1]);
    crecvtypes[size-1] = PMPI_Type_f2c(recvtypes[size-1]);
    --size;
  }

  *ierr = MPI_Alltoallw(sendbuf, sendcounts, sdispls, csendtypes, recvbuf,
                recvcounts, rdispls, crecvtypes, ccomm);

  free(csendtypes);
  free(crecvtypes);

  SCOREP_IN_MEASUREMENT_DECREMENT();
}
#endif

#if HAVE(DECL_PMPI_IALLTOALLW) && ! defined(SCOREP_MPI_NO_COLL)
/**
 * Measurement wrapper for MPI_Ialltoallw
 * @note Manually created wrapper
 * @note Fortran interface
 * @note Introduced with MPI 3.0
 * @ingroup coll
 */
void FSUB(MPI_Ialltoallw)(void*     sendbuf,
                          MPI_Fint* sendcounts,
                          MPI_Fint* sdispls,
                          MPI_Fint* sendtypes,
                          void*     recvbuf,
                          MPI_Fint* recvcounts,
                          MPI_Fint* rdispls,
                          MPI_Fint* recvtypes,
                          MPI_Fint* comm,
                          MPI_Fint* request,
                          MPI_Fint* ierr)
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  MPI_Datatype* csendtypes;
  MPI_Datatype* crecvtypes;
  MPI_Comm      ccomm;
  MPI_Request   crequest;
  int           size;

  #if HAVE(MPI_IN_PLACE)
  if (sendbuf == scorep_mpi_fortran_in_place)
  {
    sendbuf = MPI_IN_PLACE;
  }
  #endif
  #if HAVE(MPI_BOTTOM)
  if (sendbuf == scorep_mpi_fortran_bottom)
  {
    sendbuf = MPI_BOTTOM;
  }
  #endif
  #if HAVE(MPI_BOTTOM)
  if (recvbuf == scorep_mpi_fortran_bottom)
  {
    recvbuf = MPI_BOTTOM;
  }
  #endif

  ccomm = PMPI_Comm_f2c(*comm);
  PMPI_Comm_size(ccomm, &size);

  csendtypes = malloc(size * sizeof(MPI_Datatype));
  crecvtypes = malloc(size * sizeof(MPI_Datatype));

  while (size > 0)
  {
    csendtypes[size-1] = PMPI_Type_f2c(sendtypes[size-1]);
    crecvtypes[size-1] = PMPI_Type_f2c(recvtypes[size-1]);
    --size;
  }

  *ierr = MPI_Ialltoallw(sendbuf, sendcounts, sdispls, csendtypes, recvbuf,
                recvcounts, rdispls, crecvtypes, ccomm, &crequest);

  *request = PMPI_Request_c2f(crequest);

  free(csendtypes);
  free(crecvtypes);
  SCOREP_IN_MEASUREMENT_DECREMENT();
}
#endif

#pragma wrapgen multiple restrict(v2+gcoll+!nAlltoallw+!nIalltoallw) skel/SCOREP_Mpi_F2c_C2f.w
#endif

/**
 * @}
 */
