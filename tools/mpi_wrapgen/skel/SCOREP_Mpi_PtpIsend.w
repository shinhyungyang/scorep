${guard:start}
/**
 * Measurement wrapper for ${name}
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_PtpIsend.w
 * @note C interface
 * @note Introduced with MPI ${mpi:version}
 * @ingroup ${group|lowercase}
 */
${proto:c}
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  ${rtype} return_val;

  ${guard:hooks}
    ${declarehooks};
  ${guard:end}

  const int xnb_active = (scorep_mpi_enabled & SCOREP_MPI_ENABLED_XNONBLOCK);
  if (SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_${group|uppercase}))
  {
    int sz;
    SCOREP_MpiRequestId reqid = scorep_mpi_get_request_id();
    SCOREP_MPI_EVENT_GEN_OFF();
    SCOREP_EnterWrappedRegion(scorep_mpi_regions[SCOREP_MPI_REGION__${name|uppercase}],
                              ( intptr_t )P${name});

	${guard:hooks}
    ${check:hooks}
        ${call:prehook};
    ${guard:end}

    if (dest != MPI_PROC_NULL)
    {
      PMPI_Type_size(datatype, &sz);
      if (xnb_active)
         SCOREP_MpiIsend(dest, SCOREP_MPI_COMM_HANDLE(comm),
                         tag, (uint64_t)count * sz, reqid);
      else
         SCOREP_MpiSend(dest, SCOREP_MPI_COMM_HANDLE(comm),
                     tag, (uint64_t)count * sz);

    }

    SCOREP_ENTER_WRAPPED_REGION();
    return_val = ${call:pmpi};
    SCOREP_EXIT_WRAPPED_REGION();
    if (xnb_active && dest != MPI_PROC_NULL && return_val == MPI_SUCCESS)
    {
       scorep_mpi_request_create(*request, SCOREP_MPI_REQUEST_SEND,
                           tag, dest, (uint64_t)count*sz, datatype, comm, reqid);

        ${guard:hooks}
      	${check:hooks}
        	${call:posthook};
    	${guard:end}

    }
    SCOREP_ExitRegion(scorep_mpi_regions[SCOREP_MPI_REGION__${name|uppercase}]);
    SCOREP_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = ${call:pmpi};
  }
  SCOREP_IN_MEASUREMENT_DECREMENT();

  return return_val;
}
${guard:end}
